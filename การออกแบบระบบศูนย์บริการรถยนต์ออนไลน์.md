## ระบบศูนย์บริการรถยนต์ออนไลน์
- ระบบศูนย์บริการรถยนต์ออนไลน์ที่ออกแบบนี้เป็นสถาปัตยกรรมแบบ Microservices  
- ใช้เทคโนโลยีที่ทันสมัยและประสิทธิภาพสูง โดยแบ่งเป็นส่วนประกอบหลัก 5 ส่วนที่ทำงานร่วมกันอย่างมีประสิทธิภาพ

### ฐานข้อมูล PostgreSQL ออกแบบตามหลักการ normalization เพื่อลดความซ้าซ้อนของข้อมูล  
- ใช้ data types ที่เหมาะสม เช่น JSONB สำหรับ JSON data, UUID สำหรับ unique identifiers และ ARRAY สำหรับข้อมูลแบบรายการ  
- ใช้ connection pooling ด้วยเครื่องมืออย่าง PgBouncer / Pgpool-II เพื่อจัดการ concurrent connections ได้อย่างมีประสิทธิภาพ  
- สร้าง indexes แบบมีกลยุทธ์โดยใช้ B-tree หรือ hash indexes สำหรับ high-read operations และ partition tables ขนาดใหญ่เพื่อเพิ่มประสิทธิภาพ

### Redis Cache
- Redis ทำหน้าที่เป็น distributed cache สำหรับลด response time ของ microservices 
- ใช้ query caching pattern โดย deploy Redis cache แdfยกสำหรับแต่ละ microservice  
- กำหนด eviction policies ที่เหมาะสม เช่น LRU การจัดการ transaction ระหว่าง DB กับ Kafka ใน Spring(Least Recently Used), LFU (Least Frequently Used) หรือ TTL (Time-to-Live)  
- ใช้ Redis Pub/Sub สำหรับ cache synchronization ระหว่าง microservices เพื่อให้ข้อมูลใน cache มีความ consistent

### การพัฒนา

- การออกแบบฐานข้อมูลศูนย์บริการรถยนต์ มี entities หลัก 
- Customers (ลูกค้า),
- Vehicles (รถยนต์),
- Services (บริการ),
- Bookings (การจอง),
- Payments (การชำระเงิน),
- Employees (พนักงาน)
- Repair Records (บันทึกการซ่อม)  ใช้ constraints อย่าง NOT NULL, UNIQUE และ CHECK เพื่อรักษา data integrity  
- ระบบควรรองรับการจองนัดหมาย
- ระบบการตรวจสอบสถานะการซ่อม
- ระบบการชำระเงินออนไลน์
- ระบบการติดตามประวัติการบริการ


### สถาปัตยกรรมระบบ API
## Frontend  ส่วนหน้า  
- ระบบ API แรกใช้ Node.js กับ Nuxt.js framework พร้อม ORM สำหรับจัดการฐานข้อมูลและ JWT authentication สำหรับการยืนยันตัวตน 
- ระบบนี้รับผิดชอบในการจัดการคำขอจากส่วนหน้า (Frontend) โดยใช้ HTTP-only cookies เพื่อเพิ่มความปลอดภัย 
- และมีการ generate JWT token ที่มีอายุ 7 วัน  
- ส่วนนี้เหมาะสำหรับจัดการ user authentication, 
- session management 
- และ API endpoints สำหรับการโต้ตอบกับผู้ใช้โดยตรง

### ระบบ Frontend และฐานข้อมูล

1. ReactJS Frontend
- ส่วนหน้าใช้ ReactJS ซึ่งเป็น component-based architecture ที่มี virtual DOM สำหรับการ render ที่มีประสิทธิภาพ  
- แยก components เป็น Presentational Components (UI only) 
- Container Components (state และ logic management)  
- ใช้ React Hooks เช่น useState, useEffect, useContext
- useReducer สำหรับจัดการ state อย่างมีประสิทธิภาพ  
- สำหรับการเรียก API ใช้ Axios พร้อมกับ React.lazy() สำหรับ lazy loading เพื่อลด bundle size

2. Backend  (ระบบ API)  Nestjs Framework
- Apache Kafka + Java Spring Boot ทำหน้าที่เป็น producer และ consumer ของ Kafka โดยใช้ KafkaTemplate สำหรับส่งข้อความและ @KafkaListener สำหรับรับข้อความ  
- ส่วนนี้ สำหรับจัดการ business logic ที่ซับซ้อน เช่น การจัดการคิวงานซ่อม การแจ้งเตือน และการประมวลผลข้อมูลแบบ asynchronous
- Apache Kafka + Java Spring Boot ระบบ Flow สำหรับ Spring Boot + Kafka (Producer & Consumer)
- ระบบศูนย์บริการรถยนต์ออนไลน์ที่ใช้ Spring Boot กับ Apache Kafka จะออกแบบเป็นสถาปัตยกรรมแบบ event-driven ที่ microservices สื่อสารกันผ่าน events  
- ระบบนี้แบ่งเป็น 4 กระบวนการหลักที่ทำงานร่วมกันอย่างมีประสิทธิภาพ
  
**Producers (ส่งข้อความ)**

- API Gateway Service - รับ HTTP requests จาก frontend
- Booking Service - จัดการการจองนัดหมาย
- Repair Service - จัดการงานซ่อม
- Payment Service - ประมวลผลการชำระเงิน

**Kafka Cluster**

- Topics: `booking-events`, `repair-events`, `payment-events`, `notification-events`
- Partitions: แต่ละ topic มี 10 partitions เพื่อรองรับการประมวลผลแบบ parallel
- Replication Factor: 3 เพื่อความปลอดภัยของข้อมูล

**Consumers (รับข้อความ)**
- Notification Service - ส่งการแจ้งเตือนให้ลูกค้าและพนักงาน
- Analytics Service - วิเคราะห์ข้อมูลและสร้างรายงาน
- Cache Sync Service - อัพเดท Redis cache
- Audit Service - บันทึก audit logs

## Flow 1: การจองนัดหมายบริการ (Booking Flow)
### ขั้นตอนการทำงาน

**1. ลูกค้าสร้างการจอง**
```
ReactJS Frontend → POST /api/v1/bookings (customerId, vehicleId, serviceType, bookingDate)
```
**2. Booking Service (Producer)**
```java
        // ตรวจสอบความพร้อม
        if (isSlotAvailable(bookingDate)) {
            // บันทึกลง PostgreSQL
            Booking booking = bookingRepository.save(newBooking);
            
            // อัพเดท Redis cache
            redisTemplate.opsForValue().set("booking:" + booking.getId(), booking);
            
            // สร้าง Event
            BookingCreatedEvent event = BookingCreatedEvent.builder()
                .eventId(UUID.randomUUID().toString())
                .eventType("BOOKING_CREATED")
                .bookingId(booking.getId())
                .customerId(booking.getCustomerId())
                .bookingDate(booking.getBookingDate())
                .timestamp(Instant.now())
                .build();
            
            // Publish ไปยัง Kafka
            kafkaTemplate.send("booking-events", booking.getId(), event);
        }
```
**3. Consumers รับและประมวลผล**
```java
    // Notification Service Consumer
    @KafkaListener(topics = "booking-events", groupId = "notification-group")
    public void handleBookingEvent(BookingCreatedEvent event) {
        // ส่งอีเมล/SMS ยืนยันการจอง
        notificationService.sendBookingConfirmation(event);
        
        // ส่ง push notification
        fcmService.sendNotification(event.getCustomerId(), 
            "การจองของคุณได้รับการยืนยันแล้ว");
    }

// Analytics Service Consumer
    @KafkaListener(topics = "booking-events", groupId = "analytics-group")
    public void analyzeBooking(BookingCreatedEvent event) {
        // บันทึกข้อมูลสำหรับ dashboard
        analyticsRepository.recordBooking(event);
        
        // อัพเดทสถิติ real-time
        redisTemplate.opsForValue().increment("daily:bookings:" + LocalDate.now());
    }

// Audit Service Consumer
    @KafkaListener(topics = "booking-events", groupId = "audit-group")
    public void auditBooking(BookingCreatedEvent event) {
        // บันทึก audit log
        auditLogRepository.save(AuditLog.from(event));
}
```
## Flow 2: กระบวนการซ่อม (Repair Flow)
### Event-Driven Repair Workflow
**1. เริ่มงานซ่อม**
```
    Technician App → POST /api/v1/repairs/start(bookingId, technicianId, estimatedTime)
    Repair Service (Producer) →
        ├─ Save to PostgreSQL
        ├─ Update Redis cache
        └─ Publish "REPAIR_STARTED" event to Kafka
```
**2. อัพเดทสถานะระหว่างซ่อม**

```java
    // สร้าง multiple events ตามสถานะ
    RepairStatusEvent event = RepairStatusEvent.builder()
        .eventType("REPAIR_IN_PROGRESS")
        .status("DIAGNOSING") // → REPAIRING → TESTING
        .progressPercentage(25)
        .build();
    kafkaTemplate.send("repair-events", repairId, event);
```

**3. Real-time Status Updates**
```java
    // Consumer อัพเดทข้อมูลให้ลูกค้าเห็น real-time
    @KafkaListener(topics = "repair-events", groupId = "status-update-group")
    public void updateRepairStatus(RepairStatusEvent event) {
        // อัพเดท Redis สำหรับ real-time query
        redisTemplate.opsForHash().put(
            "repair:status:" + event.getRepairId(),
            "progress", event.getProgressPercentage()
        );
        // ส่ง notification ให้ลูกค้า
        webSocketService.sendToUser(event.getCustomerId(), event);
    }
```

**4. ซ่อมเสร็จสิ้น**
```
    Repair Service → Publish "REPAIR_COMPLETED" event
                ↓
    Payment Service Consumer → สร้างใบแจ้งหนี้
    Notification Service → แจ้งเตือนลูกค้ามารับรถ
    Inventory Service → อัพเดท stock อะไหล่
```

## Flow 3: การชำระเงิน (Payment Flow)
### Event Chain Pattern

**1. สร้าง Invoice**
```java
        // Payment Service รอ REPAIR_COMPLETED event
        @KafkaListener(topics = "repair-events")
        public void onRepairCompleted(RepairCompletedEvent event) {
            // สร้าง invoice
            Invoice invoice = invoiceService.createInvoice(event.getRepairId());
            // Publish INVOICE_CREATED event
            PaymentEvent paymentEvent = new PaymentEvent(
                "INVOICE_CREATED", invoice.getId(), invoice.getAmount()
            );
            kafkaTemplate.send("payment-events", invoice.getId(), paymentEvent);
        }
```
**2. ประมวลผลการชำระเงิน**
```
    Customer → POST /api/v1/payments
        ↓
    Payment Service (Producer) →
        ├─ เรียก Payment Gateway API
        ├─ บันทึกผล transaction ใน PostgreSQL
        └─ Publish "PAYMENT_COMPLETED" event
            ↓
    Consumers:
        ├─ Notification Service → ส่งใบเสร็จทาง email
        ├─ Booking Service → อัพเดทสถานะเป็น "PAID"
        └─ Analytics Service → บันทึกรายได้
```
## Flow 4: การจัดการข้อผิดพลาด (Error Handling Flow)
### Saga Pattern with Compensation
**Distributed Transaction Management**
```java
// หากการชำระเงินล้มเหลว
@KafkaListener(topics = "payment-events")
public void handlePaymentFailed(PaymentFailedEvent event) {
    // Publish compensation events
    BookingCompensationEvent compensation = new BookingCompensationEvent(
        "ROLLBACK_BOOKING", event.getBookingId()
    );
    kafkaTemplate.send("compensation-events", compensation);
}

// Booking Service รับ compensation event
@KafkaListener(topics = "compensation-events")
public void compensateBooking(BookingCompensationEvent event) {
    // Rollback การจอง
    bookingService.cancelBooking(event.getBookingId());
    
    // คืนเงินหากมีการจ่ายล่วงหน้า
    // แจ้งเตือนลูกค้า
}
```
### Retry และ Dead Letter Queue
```java
// Configuration สำหรับ retry mechanism
@Bean
public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory() {
    factory.setCommonErrorHandler(new DefaultErrorHandler(
        new DeadLetterPublishingRecoverer(kafkaTemplate),
        new FixedBackOff(1000L, 3L) // Retry 3 ครั้ง ห่างกัน 1 วินาที
    ));
    return factory;
}
// Consumer with error handling
@KafkaListener(topics = "booking-events")
public void processBooking(BookingEvent event) {
    try {
        bookingService.process(event);
    } catch (RetryableException e) {
        // Kafka จะ retry อัตโนมัติ
        throw e;
    } catch (NonRetryableException e) {
        // ส่งไป DLQ ทันที
        log.error("Non-retryable error", e);
        throw e;
    }
}
```
## สรุปโครงสร้าง Event Flow
| Event Type | Producer | Topic | Consumers | Action |
| :-- | :-- | :-- | :-- | :-- |
| BOOKING_CREATED | Booking Service | booking-events | Notification, Analytics, Audit | ส่งการแจ้งเตือน, บันทึกสถิติ |
| REPAIR_STARTED | Repair Service | repair-events | Status Update, Notification | อัพเดทสถานะ real-time |
| REPAIR_COMPLETED | Repair Service | repair-events | Payment, Notification, Inventory | สร้าง invoice, อัพเดท stock |
| PAYMENT_COMPLETED | Payment Service | payment-events | Notification, Booking, Analytics | ส่งใบเสร็จ, ปิดงาน |
| NOTIFICATION_SENT | Notification Service | notification-events | Analytics, Audit | ติดตามประสิทธิภาพการแจ้งเตือน |

- ระบบนี้รองรับ asynchronous communication, fault tolerance และ scalability สูง  โดยแต่ละ microservice สามารถ scale แยกอิสระตามปริมาณ events ที่ต้องประมวลผล

# การจัดการ transaction ระหว่าง DB กับ Kafka ใน Spring


## การจัดการ Transaction ระหว่าง Database กับ Kafka ใน Spring Boot

การจัดการ transaction ระหว่าง Database และ Kafka ใน Spring Boot ต้องเข้าใจว่า Kafka ไม่รองรับ XA transactions แบบ distributed ดังนั้น Spring จะจัดการ transactions แยกกันแต่ synchronize ให้ทำงานร่วมกัน  มี 3 วิธีหลักในการจัดการ transactions นี้

## วิธีที่ 1: Database Commit First (Default)

### Configuration

```properties
# application.properties
spring.kafka.bootstrap-servers=localhost:9092
spring.kafka.producer.transaction-id-prefix=tx-
spring.kafka.consumer.enable-auto-commit=false
spring.kafka.consumer.properties.isolation.level=read_committed

# Database
spring.datasource.url=jdbc:postgresql://localhost:5432/carservice
spring.datasource.username=postgres
spring.datasource.password=password
```


### Transaction Manager Setup

```java
@Configuration
public class TransactionConfig {
    
    // Spring Boot สร้าง transaction managers อัตโนมัติ:
    // 1. transactionManager (JPA/DataSource)
    // 2. kafkaTransactionManager (Kafka)
    
    @Bean
    public DataSourceTransactionManager dstm(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```


### Implementation: Consumer Listener

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class BookingEventListener {
    
    private final BookingRepository bookingRepository;
    private final KafkaTemplate<String, Object> kafkaTemplate;
    private final JdbcTemplate jdbcTemplate;
    
    /**
     * Kafka Listener container เริ่ม Kafka transaction
     * @Transactional เริ่ม DB transaction
     * 
     * ลำดับการ commit:
     * 1. DB commits first
     * 2. Kafka commits second
     * 
     * หาก Kafka commit ล้มเหลว: message จะถูก redelivered
     * ดังนั้น DB operation ต้องเป็น idempotent
     */
    @KafkaListener(
        id = "booking-listener",
        topics = "booking-events",
        groupId = "booking-consumer-group"
    )
    @Transactional("dstm")  // ใช้ DataSource Transaction Manager
    public void handleBookingEvent(BookingEvent event) {
        log.info("Received booking event: {}", event.getEventId());
        
        // 1. บันทึกข้อมูลลง PostgreSQL
        Booking booking = Booking.builder()
            .id(event.getBookingId())
            .customerId(event.getCustomerId())
            .vehicleId(event.getVehicleId())
            .bookingDate(event.getBookingDate())
            .status("CONFIRMED")
            .build();
        
        bookingRepository.save(booking);
        
        // 2. ส่ง notification event ไปยัง Kafka
        // KafkaTemplate จะ synchronize กับ DB transaction
        NotificationEvent notification = NotificationEvent.builder()
            .eventId(UUID.randomUUID().toString())
            .customerId(event.getCustomerId())
            .message("การจองของคุณได้รับการยืนยัน")
            .timestamp(Instant.now())
            .build();
        
        kafkaTemplate.send("notification-events", notification);
        
        // Method จบ: 
        // 1. DB transaction commits
        // 2. Kafka transaction commits
    }
}
```


### Implementation: Producer Service

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class RepairService {
    
    private final RepairRepository repairRepository;
    private final KafkaTemplate<String, Object> kafkaTemplate;
    
    /**
     * Producer-only transaction
     * KafkaTemplate synchronizes กับ DB transaction
     */
    @Transactional("dstm")
    public RepairResponse startRepair(RepairRequest request) {
        // 1. บันทึกข้อมูลการซ่อมใน database
        Repair repair = Repair.builder()
            .id(UUID.randomUUID().toString())
            .bookingId(request.getBookingId())
            .technicianId(request.getTechnicianId())
            .status("IN_PROGRESS")
            .estimatedCost(request.getEstimatedCost())
            .createdAt(LocalDateTime.now())
            .build();
        
        Repair savedRepair = repairRepository.save(repair);
        
        // 2. Publish event ไปยัง Kafka
        // KafkaTemplate จะรอจน DB commit ก่อน
        RepairEvent event = RepairEvent.builder()
            .eventId(UUID.randomUUID().toString())
            .eventType("REPAIR_STARTED")
            .repairId(savedRepair.getId())
            .timestamp(Instant.now())
            .build();
        
        kafkaTemplate.send("repair-events", savedRepair.getId(), event);
        
        // ลำดับการ commit:
        // 1. PostgreSQL transaction commits
        // 2. Kafka transaction commits
        
        return RepairResponse.from(savedRepair);
    }
}
```


## วิธีที่ 2: Kafka Commit First (Nested Transactions)

### Implementation

```java
@Service
@RequiredArgsConstructor
public class PaymentService {
    
    private final PaymentRepository paymentRepository;
    private final JdbcTemplate jdbcTemplate;
    
    /**
     * Outer method ใช้ DataSource Transaction Manager
     * Inner method ใช้ Kafka Transaction Manager
     * 
     * ลำดับการ commit:
     * 1. Kafka commits first
     * 2. DB commits only if Kafka succeeds
     */
    @Transactional("dstm")
    public void processPayment(PaymentRequest request) {
        // 1. บันทึกข้อมูลใน database
        jdbcTemplate.execute(
            "INSERT INTO payments (id, booking_id, amount, status) " +
            "VALUES ('" + request.getId() + "', '" + request.getBookingId() + 
            "', " + request.getAmount() + ", 'PENDING')"
        );
        
        // 2. เรียก inner method เพื่อส่ง Kafka message
        sendPaymentEvent(request);
        
        // Kafka commits ก่อน (จาก inner method)
        // จากนั้น DB commits
    }
    
    @Transactional("kafkaTransactionManager")
    public void sendPaymentEvent(PaymentRequest request) {
        PaymentEvent event = PaymentEvent.builder()
            .eventId(UUID.randomUUID().toString())
            .eventType("PAYMENT_PROCESSED")
            .paymentId(request.getId())
            .amount(request.getAmount())
            .build();
        
        kafkaTemplate.send("payment-events", event);
        
        // Kafka transaction commits เมื่อออกจาก method นี้
    }
}
```


## วิธีที่ 3: Transactional Outbox Pattern

### วิธีการทำงาน
Outbox Pattern แก้ปัญหา dual-write โดยเขียนข้อมูลทั้ง business data และ outbox message ลงใน database ในหนึ่ง transaction จากนั้นใช้กระบวนการแยกต่างหากในการอ่าน outbox และส่งไปยัง Kafka
### Database Schema

```sql
-- Business table
CREATE TABLE bookings (
    id VARCHAR(36) PRIMARY KEY,
    customer_id VARCHAR(36) NOT NULL,
    vehicle_id VARCHAR(36) NOT NULL,
    booking_date TIMESTAMP NOT NULL,
    status VARCHAR(20) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Outbox table
CREATE TABLE outbox_events (
    id VARCHAR(36) PRIMARY KEY,
    aggregate_type VARCHAR(50) NOT NULL,
    aggregate_id VARCHAR(36) NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    payload JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    processed BOOLEAN DEFAULT FALSE,
    processed_at TIMESTAMP
);

CREATE INDEX idx_outbox_processed ON outbox_events(processed, created_at);
```


### Implementation: Write to Outbox

```java
@Service
@RequiredArgsConstructor
public class BookingService {
    
    private final BookingRepository bookingRepository;
    private final OutboxEventRepository outboxEventRepository;
    private final ObjectMapper objectMapper;
    
    /**
     * เขียนทั้ง booking และ outbox event ใน transaction เดียว
     * รับประกัน atomicity
     */
    @Transactional
    public BookingResponse createBooking(BookingRequest request) {
        // 1. สร้าง booking
        Booking booking = Booking.builder()
            .id(UUID.randomUUID().toString())
            .customerId(request.getCustomerId())
            .vehicleId(request.getVehicleId())
            .bookingDate(request.getBookingDate())
            .status("PENDING")
            .build();
        
        Booking savedBooking = bookingRepository.save(booking);
        
        // 2. สร้าง outbox event
        BookingEvent event = BookingEvent.builder()
            .eventId(UUID.randomUUID().toString())
            .eventType("BOOKING_CREATED")
            .bookingId(savedBooking.getId())
            .customerId(savedBooking.getCustomerId())
            .timestamp(Instant.now())
            .build();
        
        OutboxEvent outboxEvent = OutboxEvent.builder()
            .id(event.getEventId())
            .aggregateType("Booking")
            .aggregateId(savedBooking.getId())
            .eventType(event.getEventType())
            .payload(objectMapper.writeValueAsString(event))
            .processed(false)
            .build();
        
        outboxEventRepository.save(outboxEvent);
        
        // Transaction commit: ทั้ง booking และ outbox ถูกบันทึกพร้อมกัน
        
        return BookingResponse.from(savedBooking);
    }
}
```


### Implementation: Outbox Publisher

```java
@Component
@RequiredArgsConstructor
@Slf4j
public class OutboxEventPublisher {
    
    private final OutboxEventRepository outboxEventRepository;
    private final KafkaTemplate<String, String> kafkaTemplate;
    private final ObjectMapper objectMapper;
    
    /**
     * Scheduled task ดึง unprocessed events และส่งไปยัง Kafka
     */
    @Scheduled(fixedDelay = 5000) // ทุก 5 วินาที
    @Transactional
    public void publishOutboxEvents() {
        List<OutboxEvent> events = outboxEventRepository
            .findTop100ByProcessedFalseOrderByCreatedAtAsc();
        
        for (OutboxEvent event : events) {
            try {
                // ส่งไปยัง Kafka
                String topic = determineTopicByEventType(event.getEventType());
                
                kafkaTemplate.send(topic, event.getAggregateId(), event.getPayload())
                    .addCallback(
                        result -> {
                            // สำเร็จ: mark as processed
                            event.setProcessed(true);
                            event.setProcessedAt(Instant.now());
                            outboxEventRepository.save(event);
                            log.info("Published outbox event: {}", event.getId());
                        },
                        ex -> {
                            log.error("Failed to publish outbox event: {}", 
                                event.getId(), ex);
                            // Retry ในรอบถัดไป
                        }
                    );
                
            } catch (Exception e) {
                log.error("Error processing outbox event: {}", event.getId(), e);
            }
        }
    }
    
    private String determineTopicByEventType(String eventType) {
        if (eventType.startsWith("BOOKING")) return "booking-events";
        if (eventType.startsWith("REPAIR")) return "repair-events";
        if (eventType.startsWith("PAYMENT")) return "payment-events";
        return "default-events";
    }
}
```


## การจัดการ Error และ Rollback

### Retry Mechanism

```java
@Configuration
public class KafkaErrorHandlingConfig {
    
    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, Object> 
        kafkaListenerContainerFactory(
            ConsumerFactory<String, Object> consumerFactory,
            KafkaTemplate<String, Object> kafkaTemplate) {
        
        ConcurrentKafkaListenerContainerFactory<String, Object> factory =
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory);
        
        // Error handler with retry and DLQ
        DefaultErrorHandler errorHandler = new DefaultErrorHandler(
            new DeadLetterPublishingRecoverer(kafkaTemplate),
            new FixedBackOff(2000L, 3L) // Retry 3 ครั้ง ห่างกัน 2 วินาที
        );
        
        // กำหนด exceptions ที่ควร retry
        errorHandler.addRetryableExceptions(
            TransientDataAccessException.class,
            TimeoutException.class
        );
        
        // กำหนด exceptions ที่ไม่ควร retry (ส่งไป DLQ ทันที)
        errorHandler.addNotRetryableExceptions(
            IllegalArgumentException.class,
            JsonProcessingException.class
        );
        
        factory.setCommonErrorHandler(errorHandler);
        return factory;
    }
}
```


### Idempotent Consumer

```java
@Service
@RequiredArgsConstructor
public class IdempotentBookingConsumer {
    
    private final BookingRepository bookingRepository;
    private final ProcessedMessageRepository processedMessageRepository;
    
    @KafkaListener(topics = "booking-events")
    @Transactional
    public void handleBooking(BookingEvent event) {
        // ตรวจสอบว่าเคย process message นี้แล้วหรือไม่
        if (processedMessageRepository.existsById(event.getEventId())) {
            log.warn("Duplicate message detected: {}", event.getEventId());
            return; // Skip duplicate
        }
        
        // Process booking
        Booking booking = bookingRepository.findById(event.getBookingId())
            .orElse(new Booking());
        booking.setStatus("CONFIRMED");
        bookingRepository.save(booking);
        
        // บันทึกว่าได้ process message นี้แล้ว
        ProcessedMessage processed = new ProcessedMessage(
            event.getEventId(), 
            Instant.now()
        );
        processedMessageRepository.save(processed);
    }
}
```
## สรุปการเปรียบเทียบ  
| แนวทาง | ข้อดี | ข้อเสีย | Use Case |
| :-- | :-- | :-- | :-- |
| DB Commit First | ง่าย, built-in support | Message อาจ redelivered, ต้อง idempotent | Consumer ที่ไม่ซับซ้อน |
| Kafka Commit First | Kafka guarantees ก่อน | DB อาจล้มเหลวหลัง Kafka commit | Critical event publishing |
| Outbox Pattern | Guaranteed delivery, true atomicity | ซับซ้อนกว่า, latency สูงขึ้น | Mission-critical systems |
 

- สำหรับระบบศูนย์บริการรถยนต์ ควรใช้ Outbox Pattern สำหรับ critical operations เช่น payment และใช้ DB Commit First สำหรับ operations ทั่วไปเพื่อความเรียบง่าย

<hr> #######################################  

## ระบบ Backend API (NestJS Framework )

NestJS เป็น progressive Node.js framework ที่ใช้ TypeScript และออกแบบตามหลัก SOLID principles เหมาะสำหรับสร้าง scalable server-side applications  สำหรับระบบศูนย์บริการรถยนต์ออนไลน์ ระบบจะประกอบด้วย JWT authentication, query caching, และโครงสร้าง modular ที่มีประสิทธิภาพ

## โครงสร้างโปรเจกต์ (Project Structure)
### Modular Architecture

```
  car-service-api/
  ├── src/
  │   ├── config/                    # Configuration files
  │   │   ├── database.config.ts
  │   │   ├── redis.config.ts
  │   │   └── jwt.config.ts
  │   │
  │   ├── common/                    # Global shared resources
  │   │   ├── decorators/           # Custom decorators
  │   │   │   ├── roles.decorator.ts
  │   │   │   └── public.decorator.ts
  │   │   ├── guards/               # Global guards
  │   │   │   ├── jwt-auth.guard.ts
  │   │   │   └── roles.guard.ts
  │   │   ├── interceptors/         # Global interceptors
  │   │   │   ├── logging.interceptor.ts
  │   │   │   └── transform.interceptor.ts
  │   │   ├── filters/              # Exception filters
  │   │   │   └── http-exception.filter.ts
  │   │   ├── pipes/                # Validation pipes
  │   │   │   └── validation.pipe.ts
  │   │   └── middleware/           # Middleware
  │   │       └── logger.middleware.ts
  │   │
  │   ├── modules/     # Feature modules
  │   │   ├── auth/
  │   │   │   ├── dto/
  │   │   │   │   ├── login.dto.ts
  │   │   │   │   └── register.dto.ts
  │   │   │   ├── strategies/
  │   │   │   │   ├── jwt.strategy.ts
  │   │   │   │   └── local.strategy.ts
  │   │   │   ├── auth.controller.ts
  │   │   │   ├── auth.service.ts
  │   │   │   └── auth.module.ts
  │   │   │
  │   │   ├── users/
  │   │   │   ├── entities/
  │   │   │   │   └── user.entity.ts
  │   │   │   ├── dto/
  │   │   │   │   ├── create-user.dto.ts
  │   │   │   │   └── update-user.dto.ts
  │   │   │   ├── users.controller.ts
  │   │   │   ├── users.service.ts
  │   │   │   ├── users.repository.ts
  │   │   │   └── users.module.ts
  │   │   │
  │   │   ├── bookings/
  │   │   │   ├── entities/
  │   │   │   │   └── booking.entity.ts
  │   │   │   ├── dto/
  │   │   │   ├── bookings.controller.ts
  │   │   │   ├── bookings.service.ts
  │   │   │   └── bookings.module.ts
  │   │   │
  │   │   ├── repairs/
  │   │   ├── vehicles/
  │   │   ├── payments/
  │   │   └── notifications/
  │   │
  │   ├── database/      # Database related
  │   │   ├── migrations/
  │   │   ├── seeds/
  │   │   └── factories/
  │   │
  │   ├── app.module.ts             # Root module
  │   └── main.ts                   # Entry point
  │
  ├── test/                         # E2E tests
  ├── .env                          # Environment variables
  └── package.json
```


## Core Modules และ Functions
### 1. Authentication Module (JWT)

**Installation**

```bash
npm install @nestjs/jwt @nestjs/passport passport passport-jwt bcrypt
npm install -D @types/passport-jwt @types/bcrypt
```

**JWT Configuration** (`src/config/jwt.config.ts`)

```typescript
import { ConfigService } from '@nestjs/config';
import { JwtModuleOptions } from '@nestjs/jwt';

export const getJwtConfig = (configService: ConfigService): JwtModuleOptions => ({
  secret: configService.get('JWT_SECRET'),
  signOptions: {
    expiresIn: configService.get('JWT_EXPIRATION', '7d'),
    algorithm: 'HS256',
  },
});
```

**Auth Module** (`src/modules/auth/auth.module.ts`)

```typescript
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './strategies/jwt.strategy';
import { LocalStrategy } from './strategies/local.strategy';
import { UsersModule } from '../users/users.module';
import { getJwtConfig } from '../../config/jwt.config';

@Module({
  imports: [
    UsersModule,
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.registerAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: getJwtConfig,
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, LocalStrategy],
  exports: [AuthService, JwtModule],
})
export class AuthModule {}
```

**Auth Service** (`src/modules/auth/auth.service.ts`)

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from '../users/users.service';
import * as bcrypt from 'bcrypt';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  // Validate user credentials
  async validateUser(email: string, password: string): Promise<any> {
    const user = await this.usersService.findByEmail(email);
    
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isPasswordValid = await bcrypt.compare(password, user.password);
    
    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const { password: _, ...result } = user;
    return result;
  }

  // Register new user
  async register(registerDto: RegisterDto) {
    const hashedPassword = await bcrypt.hash(registerDto.password, 10);
    
    const user = await this.usersService.create({
      ...registerDto,
      password: hashedPassword,
    });

    const token = await this.generateToken(user);
    
    return {
      user: {
        id: user.id,
        email: user.email,
        name: user.name,
      },
      token,
    };
  }

  // Login user
  async login(loginDto: LoginDto) {
    const user = await this.validateUser(loginDto.email, loginDto.password);
    const token = await this.generateToken(user);

    return {
      user,
      token,
    };
  }

  // Generate JWT token
  private async generateToken(user: any) {
    const payload = { 
      sub: user.id, 
      email: user.email,
      roles: user.roles || ['user']
    };

    return {
      accessToken: this.jwtService.sign(payload),
      expiresIn: '7d',
    };
  }

  // Refresh token
  async refreshToken(userId: string) {
    const user = await this.usersService.findById(userId);
    return this.generateToken(user);
  }
}
```

**JWT Strategy** (`src/modules/auth/strategies/jwt.strategy.ts`)

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { UsersService } from '../../users/users.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private configService: ConfigService,
    private usersService: UsersService,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get('JWT_SECRET'),
    });
  }

  async validate(payload: any) {
    const user = await this.usersService.findById(payload.sub);
    
    if (!user) {
      throw new UnauthorizedException();
    }

    return {
      id: user.id,
      email: user.email,
      roles: user.roles,
    };
  }
}
```

**Auth Controller** (`src/modules/auth/auth.controller.ts`)

```typescript
import { Controller, Post, Body, UseGuards, Get, Request } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { JwtAuthGuard } from '../../common/guards/jwt-auth.guard';
import { Public } from '../../common/decorators/public.decorator';

@Controller('api/v1/auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Public()
  @Post('register')
  async register(@Body() registerDto: RegisterDto) {
    return this.authService.register(registerDto);
  }

  @Public()
  @Post('login')
  async login(@Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }

  @UseGuards(JwtAuthGuard)
  @Get('profile')
  async getProfile(@Request() req) {
    return req.user;
  }

  @UseGuards(JwtAuthGuard)
  @Post('refresh')
  async refreshToken(@Request() req) {
    return this.authService.refreshToken(req.user.id);
  }
}
```


### 2. Database Configuration (TypeORM + PostgreSQL)

**Installation**

```bash
  npm install @nestjs/typeorm typeorm pg typeorm-naming-strategies
```

**Database Config** (`src/config/database.config.ts`)

```typescript
  import { TypeOrmModuleOptions } from '@nestjs/typeorm';
  import { ConfigService } from '@nestjs/config';
  import { SnakeNamingStrategy } from 'typeorm-naming-strategies';

  export const getDatabaseConfig = (
    configService: ConfigService,
  ): TypeOrmModuleOptions => ({
    type: 'postgres',
    host: configService.get('DB_HOST', 'localhost'),
    port: configService.get('DB_PORT', 5432),
    username: configService.get('DB_USERNAME'),
    password: configService.get('DB_PASSWORD'),
    database: configService.get('DB_NAME'),
    entities: ['dist/**/*.entity{.ts,.js}'],
    migrations: ['dist/database/migrations/*{.ts,.js}'],
    synchronize: configService.get('NODE_ENV') === 'development',
    logging: configService.get('NODE_ENV') === 'development',
    namingStrategy: new SnakeNamingStrategy(),
    cache: {
      type: 'redis',
      options: {
        host: configService.get('REDIS_HOST', 'localhost'),
        port: configService.get('REDIS_PORT', 6379),
      },
      duration: 30000, // 30 seconds
    },
  });
```

**Entity Example** (`src/modules/users/entities/user.entity.ts`)

```typescript
  import {
    Entity,
    PrimaryGeneratedColumn,
    Column,
    CreateDateColumn,
    UpdateDateColumn,
    DeleteDateColumn,
    Index,
  } from 'typeorm';

  @Entity('users')
  @Index(['email'], { unique: true })
  export class User {
    @PrimaryGeneratedColumn('uuid')
    id: string;

    @Column({ unique: true })
    email: string;

    @Column()
    password: string;

    @Column()
    name: string;

    @Column({ nullable: true })
    phone: string;

    @Column('simple-array', { default: '' })
    roles: string[];

    @Column({ default: true })
    isActive: boolean;

    @CreateDateColumn()
    createdAt: Date;

    @UpdateDateColumn()
    updatedAt: Date;

    @DeleteDateColumn()
    deletedAt: Date;
  }
```


### 3. Redis Caching

**Installation**

```bash
  npm install @nestjs/cache-manager cache-manager cache-manager-redis-store
  npm install -D @types/cache-manager
```

**Redis Config** (`src/config/redis.config.ts`)

```typescript
    import { CacheModuleOptions } from '@nestjs/cache-manager';
    import { ConfigService } from '@nestjs/config';
    import * as redisStore from 'cache-manager-redis-store';

    export const getRedisConfig = (
      configService: ConfigService,
    ): CacheModuleOptions => ({
      store: redisStore,
      host: configService.get('REDIS_HOST', 'localhost'),
      port: configService.get('REDIS_PORT', 6379),
      ttl: configService.get('CACHE_TTL', 300), // 5 minutes default
      max: 100, // maximum number of items in cache
    });
```

**Cache Module Setup** (`app.module.ts`)

```typescript
    import { Module } from '@nestjs/common';
    import { CacheModule } from '@nestjs/cache-manager';
    import { ConfigModule, ConfigService } from '@nestjs/config';
    import { getRedisConfig } from './config/redis.config';

    @Module({
      imports: [
        ConfigModule.forRoot({ isGlobal: true }),
        CacheModule.registerAsync({
          imports: [ConfigModule],
          inject: [ConfigService],
          useFactory: getRedisConfig,
          isGlobal: true,
        }),
        // Other modules...
      ],
    })
    export class AppModule {}
```

**Service with Caching** (`src/modules/bookings/bookings.service.ts`)

```typescript
        import { Injectable, Inject } from '@nestjs/common';
        import { InjectRepository } from '@nestjs/typeorm';
        import { Repository } from 'typeorm';
        import { CACHE_MANAGER } from '@nestjs/cache-manager';
        import { Cache } from 'cache-manager';
        import { Booking } from './entities/booking.entity';

        @Injectable()
        export class BookingsService {
          constructor(
            @InjectRepository(Booking)
            private bookingsRepository: Repository<Booking>,
            @Inject(CACHE_MANAGER)
            private cacheManager: Cache,
          ) {}

          async findAll(): Promise<Booking[]> {
            const cacheKey = 'bookings:all';
            
            // Try to get from cache first
            const cachedData = await this.cacheManager.get<Booking[]>(cacheKey);
            
            if (cachedData) {
              return cachedData;
            }

            // If not in cache, fetch from database
            const bookings = await this.bookingsRepository.find();
            
            // Store in cache for future requests
            await this.cacheManager.set(cacheKey, bookings, 300); // 5 minutes
            
            return bookings;
          }

          async findById(id: string): Promise<Booking> {
            const cacheKey = `booking:${id}`;
            
            const cached = await this.cacheManager.get<Booking>(cacheKey);
            if (cached) return cached;

            const booking = await this.bookingsRepository.findOne({ where: { id } });
            
            if (booking) {
              await this.cacheManager.set(cacheKey, booking, 600); // 10 minutes
            }
            
            return booking;
          }

          async create(createBookingDto: any): Promise<Booking> {
            const booking = this.bookingsRepository.create(createBookingDto);
            const saved = await this.bookingsRepository.save(booking);
            
            // Invalidate list cache when new booking is created
            await this.cacheManager.del('bookings:all');
            
            return saved;
          }

          async update(id: string, updateBookingDto: any): Promise<Booking> {
            await this.bookingsRepository.update(id, updateBookingDto);
            
            // Invalidate both specific and list caches
            await Promise.all([
              this.cacheManager.del(`booking:${id}`),
              this.cacheManager.del('bookings:all'),
            ]);
            
            return this.findById(id);
          }
        }
```

**Controller with Cache Interceptor**

```typescript
      import { 
        Controller, 
        Get, 
        UseInterceptors 
      } from '@nestjs/common';
      import { CacheInterceptor, CacheTTL } from '@nestjs/cache-manager';
      import { BookingsService } from './bookings.service';

      @Controller('api/v1/bookings')
      export class BookingsController {
        constructor(private readonly bookingsService: BookingsService) {}

        @Get()
        @UseInterceptors(CacheInterceptor)
        @CacheTTL(300) // Override default TTL to 5 minutes
        async findAll() {
          return this.bookingsService.findAll();
        }

        @Get(':id')
        @UseInterceptors(CacheInterceptor)
        @CacheTTL(600) // 10 minutes for individual items
        async findOne(@Param('id') id: string) {
          return this.bookingsService.findById(id);
        }
      }
```


## Request Flow และ Lifecycle

### Request Processing Order

```
  Incoming Request
      ↓
  1. Middleware (LoggerMiddleware)
      ↓
  2. Guards (JwtAuthGuard, RolesGuard)
      ↓
  3. Interceptors (Before - LoggingInterceptor, CacheInterceptor)
      ↓
  4. Pipes (ValidationPipe)
      ↓
  5. Controller Method
      ↓
  6. Service Layer
      ↓
  7. Repository/Database
      ↓
  8. Interceptors (After - TransformInterceptor)
      ↓
  9. Filters (ExceptionFilter if error)
      ↓
  Response to Client
```

### Guards Implementation
**JWT Auth Guard** (`src/common/guards/jwt-auth.guard.ts`)

```typescript
import { Injectable, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { AuthGuard } from '@nestjs/passport';
import { IS_PUBLIC_KEY } from '../decorators/public.decorator';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    
    if (isPublic) {
      return true;
    }
    
    return super.canActivate(context);
  }
}
```
**Roles Guard** (`src/common/guards/roles.guard.ts`)

```typescript
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { ROLES_KEY } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>(
      ROLES_KEY,
      [context.getHandler(), context.getClass()],
    );
    
    if (!requiredRoles) {
      return true;
    }
    
    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}
```


### Interceptors

**Logging Interceptor** (`src/common/interceptors/logging.interceptor.ts`)

```typescript
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  Logger,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  private readonly logger = new Logger(LoggingInterceptor.name);

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const { method, url } = request;
    const now = Date.now();

    return next.handle().pipe(
      tap(() => {
        const response = context.switchToHttp().getResponse();
        const delay = Date.now() - now;
        this.logger.log(
          `${method} ${url} ${response.statusCode} - ${delay}ms`,
        );
      }),
    );
  }
}
```

**Transform Interceptor** (`src/common/interceptors/transform.interceptor.ts`)

```typescript
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Response<T> {
  data: T;
  statusCode: number;
  message: string;
  timestamp: string;
}

@Injectable()
export class TransformInterceptor<T>
  implements NestInterceptor<T, Response<T>>
{
  intercept(
    context: ExecutionContext,
    next: CallHandler,
  ): Observable<Response<T>> {
    return next.handle().pipe(
      map((data) => ({
        data,
        statusCode: context.switchToHttp().getResponse().statusCode,
        message: 'Success',
        timestamp: new Date().toISOString(),
      })),
    );
  }
}
```


### Pipes

**Validation Pipe Setup** (`main.ts`)

```typescript
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Global validation pipe
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true, // Strip properties that don't have decorators
      forbidNonWhitelisted: true, // Throw error if non-whitelisted values exist
      transform: true, // Automatically transform payloads to DTO instances
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );
  
  await app.listen(3000);
}
bootstrap();
```


## Environment Configuration

**.env File**

```env
    # Application
    NODE_ENV=development
    PORT=3000

    # Database
    DB_HOST=localhost
    DB_PORT=5432
    DB_USERNAME=postgres
    DB_PASSWORD=password
    DB_NAME=car_service_db
    DB_SYNCHRONIZE=false

    # JWT
    JWT_SECRET=your-super-secret-jwt-key-change-in-production
    JWT_EXPIRATION=7d

    # Redis
    REDIS_HOST=localhost
    REDIS_PORT=6379
    CACHE_TTL=300

    # API
    API_PREFIX=api/v1
```


## สรุป Libraries และ Modules

| Library/Module | Purpose | Installation |
| :-- | :-- | :-- |
| `@nestjs/jwt` | JWT token generation | Required for authentication |
| `@nestjs/passport` | Authentication strategies | Works with passport-jwt |
| `@nestjs/typeorm` | Database ORM | PostgreSQL integration |
| `@nestjs/cache-manager` | Caching layer | Redis caching support |
| `@nestjs/config` | Environment configuration | Manages .env files |
| `class-validator` | DTO validation | Input validation pipes |
| `class-transformer` | Object transformation | DTO transformation |

ระบบนี้ใช้ modular architecture ที่แยก concerns ชัดเจน มี authentication ที่แข็งแกร่งด้วย JWT, caching layer ด้วย Redis และ lifecycle management ที่มีประสิทธิภาพผ่าน guards, interceptors และ pipes


## แผนภาพ Flow Chart: กระบวนการ Request ถึง Response ของ NestJS API

แผนภาพด้านล่างแสดงกระบวนการทำงานแบบละเอียดของ NestJS API ตั้งแต่รับ HTTP Request จนถึงส่ง Response กลับไปยัง Client โดยผ่าน Middleware, Guards, Interceptors, Pipes, Controller, Service และ Database

![แผนภาพ Flow Chart แสดงกระบวนการ Request ถึง Response ของ NestJS API - ตั้งแต่การรับ HTTP Request ผ่าน Middleware, Guards, Interceptors, Validation, Controller, Service, Database จนถึงการส่ง Response กลับไปยัง Client](https://ppl-ai-code-interpreter-files.s3.amazonaws.com/web/direct-files/2b884aa2db3bb486bc4cace0ac04c358/23f6364f-b7b1-451a-ae9f-56440b708bc2/70421ecb.png)

แผนภาพ Flow Chart แสดงกระบวนการ Request ถึง Response ของ NestJS API - ตั้งแต่การรับ HTTP Request ผ่าน Middleware, Guards, Interceptors, Validation, Controller, Service, Database จนถึงการส่ง Response กลับไปยัง Client

## อธิบายแต่ละขั้นตอนในกระบวนการ

### Layer 1: Middleware (เริ่มต้นของ Request)

**Logger Middleware**
Middleware ทำงานเป็นลำดับแรกสุดก่อน routing ใช้สำหรับ logging, CORS, compression หรือการแปลง request body  ในตัวอย่างนี้ Logger Middleware บันทึกข้อมูล request เช่น HTTP method, URL, timestamp และ client IP address 

```typescript
// ตัวอย่างการใช้งาน
@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    console.log(`${req.method} ${req.originalUrl} - ${new Date().toISOString()}`);
    next(); // ส่งต่อไปยังขั้นตอนถัดไป
  }
}
```


### Layer 2: Guards (Authentication \& Authorization)

**JWT Auth Guard**
ตรวจสอบความถูกต้องของ JWT token ใน Authorization header  หากไม่มี token หรือ token ไม่ถูกต้อง จะส่ง 401 Unauthorized Error ทันที  Guards ทำงานหลัง middleware แต่ก่อน interceptors และมีสิทธิ์ปฏิเสธ request ได้ 

**Roles Guard**
ตรวจสอบว่า user มี role ที่จำเป็นหรือไม่  เช่น endpoint สำหรับ admin เท่านั้น หากไม่มีสิทธิ์จะส่ง 403 Forbidden Error 

### Layer 3: Interceptors (Before Request)

**Cache Interceptor**
ตรวจสอบว่ามีข้อมูลใน Redis cache หรือไม่  ถ้ามี (cache hit) จะส่งข้อมูลกลับทันทีโดยไม่ต้องผ่าน controller, service หรือ database ช่วยลด response time อย่างมาก 

**Logging Interceptor**
เริ่มจับเวลาเพื่อวัด performance ของ request  Interceptors สามารถทำงานทั้งก่อนและหลังการเรียก route handler 

### Layer 4: Pipes (Validation)

**Validation Pipe**
ตรวจสอบและแปลง (transform) request data ตาม DTO (Data Transfer Object)  ใช้ decorators จาก `class-validator` เช่น `@IsString()`, `@IsEmail()`, `@IsNotEmpty()`  หากข้อมูลไม่ถูกต้องจะส่ง 400 Bad Request Error พร้อมรายละเอียด validation errors 

```typescript
// ตัวอย่าง DTO
export class CreateBookingDto {
  @IsNotEmpty()
  @IsUUID()
  customerId: string;

  @IsNotEmpty()
  @IsDateString()
  bookingDate: string;

  @IsString()
  serviceType: string;
}
```


### Layer 5: Controller (Route Handler)

**BookingsController**
รับ request ที่ผ่านการตรวจสอบทั้งหมดแล้ว  Controller มีหน้าที่รับ HTTP request และส่งต่อไปยัง Service layer  ไม่ควรมี business logic ใน controller 

```typescript
@Post()
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles('user', 'admin')
async create(@Body() createBookingDto: CreateBookingDto) {
  return this.bookingsService.create(createBookingDto);
}
```


### Layer 6: Service Layer (Business Logic)

**BookingsService**
ประมวลผล business logic ทั้งหมด  เช่น: 

- ตรวจสอบ availability ของช่วงเวลา
- Generate unique ID
- คำนวณราคา
- ตรวจสอบเงื่อนไข business rules
- เรียกใช้ repository เพื่อติดต่อ database 


### Layer 7: Repository \& Database

**TypeORM Repository**
จัดการการเข้าถึง database โดยใช้ TypeORM  รองรับ query builder, relations, transactions และ caching  ข้อมูลถูกบันทึกลง PostgreSQL database และส่งกลับมายัง service 

```typescript
// ตัวอย่างการใช้ Repository
const booking = this.bookingsRepository.create(createBookingDto);
const savedBooking = await this.bookingsRepository.save(booking);
```


### Layer 8: Response Processing

**Transform Interceptor**
แปลง response ให้อยู่ในรูปแบบมาตรฐาน  เช่น wrap ด้วย metadata อย่าง status code, message, timestamp: 

```typescript
{
  "statusCode": 201,
  "message": "Success",
  "data": { /* booking data */ },
  "timestamp": "2025-11-26T12:09:00.000Z"
}
```

**Logging Interceptor (After)**
บันทึกเวลาที่ใช้ในการประมวลผล request  เช่น "POST /api/v1/bookings 201 - 245ms" 

**Cache Update**
อัพเดทข้อมูลใหม่เข้า Redis cache เพื่อให้ request ถัดไปได้ใช้ข้อมูลจาก cache 

### Error Handling Flow

**Exception Filter**
จับ exceptions ที่เกิดขึ้นจากทุก layer  แปลงเป็น HTTP response ที่มีรูปแบบสอดคล้องกัน  ส่ง appropriate HTTP status code (400, 401, 403, 404, 500) พร้อม error message ที่เป็นมิตรกับผู้ใช้ 

```typescript
{
  "statusCode": 400,
  "message": "Validation failed",
  "errors": [
    "customerId must be a UUID",
    "bookingDate must be a valid date string"
  ],
  "timestamp": "2025-11-26T12:09:00.000Z"
}
```

## สรุปลำดับการทำงาน

| Step | Component | Purpose | Can Block Request? |
| :-- | :-- | :-- | :-- |
| 1 | Middleware | Logging, preprocessing | Yes (rarely) |
| 2 | JWT Auth Guard | Verify authentication | Yes (401) |
| 3 | Roles Guard | Check authorization | Yes (403) |
| 4 | Cache Interceptor | Check cache hit | No (shortcuts) |
| 5 | Logging Interceptor | Start timer | No |
| 6 | Validation Pipe | Validate input | Yes (400) |
| 7 | Controller | Route handling | No |
| 8 | Service | Business logic | Can throw errors |
| 9 | Repository | Database access | Can throw errors |
| 10 | Transform Interceptor | Format response | No |
| 11 | Exception Filter | Handle errors | Only on errors |

ระบบนี้ใช้ layered architecture ที่แยก concerns ชัดเจน ทำให้ code มีความเป็นระเบียบ ง่ายต่อการ maintain และ test  

<hr>
 #######################################  
<hr>

## การออกแบบระบบ ReactJS Frontend

 - ReactJS เป็น component-based library สำหรับสร้าง user interface ที่มีประสิทธิภาพ โดยใช้ Virtual DOM และ unidirectional data flow  สำหรับระบบศูนย์บริการรถยนต์ออนไลน์ ระบบ frontend จะประกอบด้วย authentication, state management, routing และ API integration

## โครงสร้างโปรเจกต์ (Project Structure)

### Folder Structure
```
car-service-frontend/
├── public/
│   ├── index.html
│   ├── favicon.ico
│   └── assets/
│       └── images/
│
├── src/
│   ├── assets/                    # Static resources
│   │   ├── images/
│   │   ├── icons/
│   │   └── styles/
│   │       └── global.css
│   │
│   ├── components/                # Reusable components
│   │   ├── common/
│   │   │   ├── Button/
│   │   │   │   ├── Button.jsx
│   │   │   │   ├── Button.test.jsx
│   │   │   │   └── Button.module.css
│   │   │   ├── Input/
│   │   │   ├── Modal/
│   │   │   ├── Loading/
│   │   │   └── ErrorBoundary/
│   │   │
│   │   └── layout/
│   │       ├── Header/
│   │       ├── Sidebar/
│   │       ├── Footer/
│   │       └── Layout.jsx
│   │
│   ├── features/                  # Feature-based modules
│   │   ├── auth/
│   │   │   ├── components/
│   │   │   │   ├── LoginForm.jsx
│   │   │   │   └── RegisterForm.jsx
│   │   │   ├── hooks/
│   │   │   │   └── useAuth.js
│   │   │   ├── services/
│   │   │   │   └── authService.js
│   │   │   └── context/
│   │   │       └── AuthContext.jsx
│   │   │
│   │   ├── bookings/
│   │   │   ├── components/
│   │   │   │   ├── BookingList.jsx
│   │   │   │   ├── BookingForm.jsx
│   │   │   │   └── BookingCard.jsx
│   │   │   ├── hooks/
│   │   │   │   └── useBookings.js
│   │   │   └── services/
│   │   │       └── bookingService.js
│   │   │
│   │   ├── repairs/
│   │   ├── vehicles/
│   │   └── payments/
│   │
│   ├── pages/                     # Page components
│   │   ├── HomePage.jsx
│   │   ├── LoginPage.jsx
│   │   ├── DashboardPage.jsx
│   │   ├── BookingsPage.jsx
│   │   ├── RepairStatusPage.jsx
│   │   └── NotFoundPage.jsx
│   │
│   ├── hooks/                     # Global custom hooks
│   │   ├── useApi.js
│   │   ├── useForm.js
│   │   └── useDebounce.js
│   │
│   ├── services/                  # API services
│   │   ├── api.js                # Axios instance
│   │   └── endpoints.js          # API endpoints
│   │
│   ├── store/                     # State management
│   │   ├── slices/
│   │   │   ├── authSlice.js
│   │   │   ├── bookingSlice.js
│   │   │   └── repairSlice.js
│   │   └── store.js
│   │
│   ├── utils/                     # Utility functions
│   │   ├── formatters.js
│   │   ├── validators.js
│   │   └── constants.js
│   │
│   ├── routes/                    # Routing configuration
│   │   ├── ProtectedRoute.jsx
│   │   └── routes.jsx
│   │
│   ├── App.jsx                    # Root component
│   ├── main.jsx                   # Entry point
│   └── index.css
│
├── package.json
├── vite.config.js
└── .env
```


## Core Implementation
### 1. Authentication System

**Auth Context** (`src/features/auth/context/AuthContext.jsx`)

```jsx
import { createContext, useState, useContext, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import authService from '../services/authService';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [token, setToken] = useState(localStorage.getItem('token'));
  const [loading, setLoading] = useState(true);
  const navigate = useNavigate();

  // Check if user is logged in on mount
  useEffect(() => {
    const initAuth = async () => {
      if (token) {
        try {
          const userData = await authService.getProfile();
          setUser(userData);
        } catch (error) {
          console.error('Failed to fetch user profile:', error);
          logout();
        }
      }
      setLoading(false);
    };
    
    initAuth();
  }, [token]);

  // Login function
  const login = async (email, password) => {
    try {
      const response = await authService.login(email, password);
      const { token: accessToken, user: userData } = response;
      
      setToken(accessToken);
      setUser(userData);
      localStorage.setItem('token', accessToken);
      
      navigate('/dashboard');
      return { success: true };
    } catch (error) {
      return { 
        success: false, 
        error: error.response?.data?.message || 'Login failed' 
      };
    }
  };

  // Register function
  const register = async (userData) => {
    try {
      const response = await authService.register(userData);
      const { token: accessToken, user: newUser } = response;
      
      setToken(accessToken);
      setUser(newUser);
      localStorage.setItem('token', accessToken);
      
      navigate('/dashboard');
      return { success: true };
    } catch (error) {
      return { 
        success: false, 
        error: error.response?.data?.message || 'Registration failed' 
      };
    }
  };

  // Logout function
  const logout = () => {
    setToken(null);
    setUser(null);
    localStorage.removeItem('token');
    navigate('/login');
  };

  const value = {
    user,
    token,
    loading,
    isAuthenticated: !!token,
    login,
    register,
    logout,
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

// Custom hook to use auth context
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

export default AuthContext;
```

**Auth Service** (`src/features/auth/services/authService.js`)

```javascript
import api from '../../../services/api';

const authService = {
  // Login user
  login: async (email, password) => {
    const response = await api.post('/auth/login', {
      email,
      password,
    });
    return response.data;
  },

  // Register new user
  register: async (userData) => {
    const response = await api.post('/auth/register', userData);
    return response.data;
  },

  // Get user profile
  getProfile: async () => {
    const response = await api.get('/auth/profile');
    return response.data;
  },

  // Refresh token
  refreshToken: async () => {
    const response = await api.post('/auth/refresh');
    return response.data;
  },

  // Logout
  logout: async () => {
    const response = await api.post('/auth/logout');
    return response.data;
  },
};

export default authService;
```


### 2. Axios Configuration

**API Instance** (`src/services/api.js`)

```javascript
import axios from 'axios';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000/api/v1';

// Create axios instance
const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor - Add auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor - Handle errors and token refresh
api.interceptors.response.use(
  (response) => {
    return response;
  },
  async (error) => {
    const originalRequest = error.config;

    // If error is 401 and we haven't retried yet
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        // Try to refresh token
        const refreshResponse = await axios.post(
          `${API_BASE_URL}/auth/refresh`,
          {},
          {
            headers: {
              Authorization: `Bearer ${localStorage.getItem('token')}`,
            },
          }
        );

        const { token } = refreshResponse.data;
        localStorage.setItem('token', token);

        // Retry original request with new token
        originalRequest.headers.Authorization = `Bearer ${token}`;
        return api(originalRequest);
      } catch (refreshError) {
        // Refresh failed, logout user
        localStorage.removeItem('token');
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    // Handle other errors
    if (error.response?.status === 403) {
      console.error('Access forbidden');
    }

    if (error.response?.status === 500) {
      console.error('Server error');
    }

    return Promise.reject(error);
  }
);

export default api;
```


### 3. Protected Routes

**Protected Route Component** (`src/routes/ProtectedRoute.jsx`)

```jsx
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../features/auth/context/AuthContext';
import Loading from '../components/common/Loading/Loading';

const ProtectedRoute = ({ children, requiredRoles = [] }) => {
  const { isAuthenticated, user, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return <Loading />;
  }

  if (!isAuthenticated) {
    // Redirect to login and save the attempted location
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  // Check if user has required roles
  if (requiredRoles.length > 0) {
    const hasRequiredRole = requiredRoles.some((role) =>
      user?.roles?.includes(role)
    );

    if (!hasRequiredRole) {
      return <Navigate to="/unauthorized" replace />;
    }
  }

  return children;
};

export default ProtectedRoute;
```

**Router Configuration** (`src/routes/routes.jsx`)

```jsx
import { createBrowserRouter } from 'react-router-dom';
import Layout from '../components/layout/Layout';
import ProtectedRoute from './ProtectedRoute';

// Pages
import HomePage from '../pages/HomePage';
import LoginPage from '../pages/LoginPage';
import RegisterPage from '../pages/RegisterPage';
import DashboardPage from '../pages/DashboardPage';
import BookingsPage from '../pages/BookingsPage';
import RepairStatusPage from '../pages/RepairStatusPage';
import AdminPage from '../pages/AdminPage';
import NotFoundPage from '../pages/NotFoundPage';

const router = createBrowserRouter([
  {
    path: '/',
    element: <Layout />,
    children: [
      {
        index: true,
        element: <HomePage />,
      },
      {
        path: 'login',
        element: <LoginPage />,
      },
      {
        path: 'register',
        element: <RegisterPage />,
      },
      {
        path: 'dashboard',
        element: (
          <ProtectedRoute>
            <DashboardPage />
          </ProtectedRoute>
        ),
      },
      {
        path: 'bookings',
        element: (
          <ProtectedRoute>
            <BookingsPage />
          </ProtectedRoute>
        ),
      },
      {
        path: 'repairs/:repairId',
        element: (
          <ProtectedRoute>
            <RepairStatusPage />
          </ProtectedRoute>
        ),
      },
      {
        path: 'admin',
        element: (
          <ProtectedRoute requiredRoles={['admin']}>
            <AdminPage />
          </ProtectedRoute>
        ),
      },
      {
        path: '*',
        element: <NotFoundPage />,
      },
    ],
  },
]);

export default router;
```


### 4. Custom Hooks

**useApi Hook** (`src/hooks/useApi.js`)

```javascript
import { useState, useEffect, useCallback } from 'react';
import api from '../services/api';

const useApi = (endpoint, options = {}) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const { 
    method = 'GET', 
    body = null, 
    immediate = true,
    onSuccess,
    onError 
  } = options;

  const execute = useCallback(
    async (overrideBody = null) => {
      setLoading(true);
      setError(null);

      try {
        const config = {
          method,
          url: endpoint,
        };

        if (overrideBody || body) {
          config.data = overrideBody || body;
        }

        const response = await api(config);
        setData(response.data);

        if (onSuccess) {
          onSuccess(response.data);
        }

        return response.data;
      } catch (err) {
        const errorMessage = err.response?.data?.message || err.message;
        setError(errorMessage);

        if (onError) {
          onError(errorMessage);
        }

        throw err;
      } finally {
        setLoading(false);
      }
    },
    [endpoint, method, body, onSuccess, onError]
  );

  useEffect(() => {
    if (immediate && method === 'GET') {
      execute();
    }
  }, [immediate, method, execute]);

  return { data, loading, error, execute, refetch: execute };
};

export default useApi;
```

**useForm Hook** (`src/hooks/useForm.js`)

```javascript
import { useState } from 'react';

const useForm = (initialValues, validationRules = {}) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Handle input change
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    const newValue = type === 'checkbox' ? checked : value;

    setValues((prev) => ({
      ...prev,
      [name]: newValue,
    }));

    // Clear error when user starts typing
    if (errors[name]) {
      setErrors((prev) => ({
        ...prev,
        [name]: '',
      }));
    }
  };

  // Handle input blur
  const handleBlur = (e) => {
    const { name } = e.target;
    setTouched((prev) => ({
      ...prev,
      [name]: true,
    }));

    // Validate field on blur
    validateField(name, values[name]);
  };

  // Validate single field
  const validateField = (name, value) => {
    if (!validationRules[name]) return true;

    const rules = validationRules[name];
    let error = '';

    if (rules.required && !value) {
      error = rules.requiredMessage || `${name} is required`;
    } else if (rules.minLength && value.length < rules.minLength) {
      error = `${name} must be at least ${rules.minLength} characters`;
    } else if (rules.pattern && !rules.pattern.test(value)) {
      error = rules.patternMessage || `Invalid ${name} format`;
    } else if (rules.custom) {
      error = rules.custom(value, values);
    }

    if (error) {
      setErrors((prev) => ({
        ...prev,
        [name]: error,
      }));
      return false;
    }

    return true;
  };

  // Validate all fields
  const validate = () => {
    const newErrors = {};
    let isValid = true;

    Object.keys(validationRules).forEach((name) => {
      const fieldValid = validateField(name, values[name]);
      if (!fieldValid) {
        isValid = false;
      }
    });

    return isValid;
  };

  // Handle form submit
  const handleSubmit = (onSubmit) => async (e) => {
    e.preventDefault();
    setIsSubmitting(true);

    // Mark all fields as touched
    const allTouched = Object.keys(values).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    setTouched(allTouched);

    // Validate
    if (validate()) {
      try {
        await onSubmit(values);
      } catch (error) {
        console.error('Form submission error:', error);
      }
    }

    setIsSubmitting(false);
  };

  // Reset form
  const reset = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
    setIsSubmitting(false);
  };

  return {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
    reset,
    setValues,
    setErrors,
  };
};

export default useForm;
```


### 5. Feature Components

**Login Form** (`src/features/auth/components/LoginForm.jsx`)

```jsx
import { useState } from 'react';
import { Link } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import useForm from '../../../hooks/useForm';
import Button from '../../../components/common/Button/Button';
import Input from '../../../components/common/Input/Input';
import './LoginForm.css';

const LoginForm = () => {
  const { login } = useAuth();
  const [apiError, setApiError] = useState('');

  const validationRules = {
    email: {
      required: true,
      pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      patternMessage: 'Please enter a valid email',
    },
    password: {
      required: true,
      minLength: 6,
    },
  };

  const {
    values,
    errors,
    touched,
    isSubmitting,
    handleChange,
    handleBlur,
    handleSubmit,
  } = useForm(
    {
      email: '',
      password: '',
    },
    validationRules
  );

  const onSubmit = async (formValues) => {
    setApiError('');
    
    const result = await login(formValues.email, formValues.password);
    
    if (!result.success) {
      setApiError(result.error);
    }
  };

  return (
    <div className="login-form">
      <h2>เข้าสู่ระบบ</h2>

      <form onSubmit={handleSubmit(onSubmit)}>
        <Input
          label="อีเมล"
          type="email"
          name="email"
          value={values.email}
          onChange={handleChange}
          onBlur={handleBlur}
          error={touched.email && errors.email}
          placeholder="example@email.com"
          required
        />

        <Input
          label="รหัสผ่าน"
          type="password"
          name="password"
          value={values.password}
          onChange={handleChange}
          onBlur={handleBlur}
          error={touched.password && errors.password}
          placeholder="••••••••"
          required
        />

        {apiError && (
          <div className="error-message">{apiError}</div>
        )}

        <Button
          type="submit"
          fullWidth
          loading={isSubmitting}
          disabled={isSubmitting}
        >
          {isSubmitting ? 'กำลังเข้าสู่ระบบ...' : 'เข้าสู่ระบบ'}
        </Button>
      </form>

      <div className="form-footer">
        <p>
          ยังไม่มีบัญชี? <Link to="/register">สมัครสมาชิก</Link>
        </p>
      </div>
    </div>
  );
};

export default LoginForm;
```

**Booking List** (`src/features/bookings/components/BookingList.jsx`)

```jsx
import { useEffect, useState } from 'react';
import useApi from '../../../hooks/useApi';
import BookingCard from './BookingCard';
import Loading from '../../../components/common/Loading/Loading';
import './BookingList.css';

const BookingList = () => {
  const [filter, setFilter] = useState('all');
  
  const { 
    data: bookings, 
    loading, 
    error, 
    refetch 
  } = useApi('/bookings', {
    method: 'GET',
    immediate: true,
  });

  const filteredBookings = bookings?.filter((booking) => {
    if (filter === 'all') return true;
    return booking.status === filter;
  });

  const handleStatusChange = async () => {
    // Refresh list after status change
    await refetch();
  };

  if (loading) {
    return <Loading />;
  }

  if (error) {
    return (
      <div className="error-container">
        <p>เกิดข้อผิดพลาด: {error}</p>
        <button onClick={refetch}>ลองใหม่</button>
      </div>
    );
  }

  return (
    <div className="booking-list">
      <div className="list-header">
        <h2>รายการจองของฉัน</h2>
        
        <div className="filter-buttons">
          <button
            className={filter === 'all' ? 'active' : ''}
            onClick={() => setFilter('all')}
          >
            ทั้งหมด
          </button>
          <button
            className={filter === 'pending' ? 'active' : ''}
            onClick={() => setFilter('pending')}
          >
            รอดำเนินการ
          </button>
          <button
            className={filter === 'confirmed' ? 'active' : ''}
            onClick={() => setFilter('confirmed')}
          >
            ยืนยันแล้ว
          </button>
          <button
            className={filter === 'completed' ? 'active' : ''}
            onClick={() => setFilter('completed')}
          >
            เสร็จสิ้น
          </button>
        </div>
      </div>

      <div className="booking-grid">
        {filteredBookings?.length > 0 ? (
          filteredBookings.map((booking) => (
            <BookingCard
              key={booking.id}
              booking={booking}
              onStatusChange={handleStatusChange}
            />
          ))
        ) : (
          <p className="no-bookings">ไม่มีรายการจอง</p>
        )}
      </div>
    </div>
  );
};

export default BookingList;
```


### 6. Main App Setup

**Main Entry** (`src/main.jsx`)

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { RouterProvider } from 'react-router-dom';
import { AuthProvider } from './features/auth/context/AuthContext';
import router from './routes/routes';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <RouterProvider router={router}>
      <AuthProvider>
        <RouterProvider router={router} />
      </AuthProvider>
    </RouterProvider>
  </React.StrictMode>
);
```

**App Component** (`src/App.jsx`)

```jsx
import { Outlet } from 'react-router-dom';
import { AuthProvider } from './features/auth/context/AuthContext';
import ErrorBoundary from './components/common/ErrorBoundary/ErrorBoundary';
import './App.css';

function App() {
  return (
    <ErrorBoundary>
      <AuthProvider>
        <div className="app">
          <Outlet />
        </div>
      </AuthProvider>
    </ErrorBoundary>
  );
}

export default App;
```


## Application Flow Diagram

### User Authentication Flow

```
1. User visits app
   ↓
2. Check localStorage for token
   ↓
3. If token exists → Fetch user profile from API
   ├─ Success → Set user state → Navigate to Dashboard
   └─ Fail → Clear token → Navigate to Login
   ↓
4. User fills login form
   ↓
5. Form validation (useForm hook)
   ├─ Invalid → Show errors
   └─ Valid → Continue
   ↓
6. Submit to API (POST /auth/login)
   ↓
7. API Response
   ├─ Success (200) → Save token → Set user → Navigate to Dashboard
   └─ Error (401) → Show error message
```


### Data Fetching Flow

```
1. Component mounts
   ↓
2. useApi hook executes
   ↓
3. Check if immediate fetch required
   ↓
4. Axios interceptor adds Bearer token
   ↓
5. Send request to API
   ↓
6. API Response
   ├─ Success → Update state with data
   ├─ 401 Unauthorized → Refresh token → Retry request
   └─ Other errors → Set error state
   ↓
7. Component renders with data/error/loading
```


### Protected Route Flow

```
1. User navigates to protected route
   ↓
2. ProtectedRoute component checks authentication
   ↓
3. Check isAuthenticated
   ├─ No → Redirect to /login (save attempted location)
   └─ Yes → Continue
   ↓
4. Check required roles (if any)
   ├─ No required role → Redirect to /unauthorized
   └─ Has required role → Render children components
```


## สรุป Key Libraries

| Library | Purpose | Installation |
| :-- | :-- | :-- |
| `react-router-dom` | Routing and navigation | `npm install react-router-dom` |
| `axios` | HTTP client for API calls | `npm install axios` |
| `@reduxjs/toolkit` | State management (optional) | `npm install @reduxjs/toolkit react-redux` |
| `react-hook-form` | Form management (alternative) | `npm install react-hook-form` |
| `react-query` | Data fetching/caching (alternative) | `npm install @tanstack/react-query` |

ระบบนี้ใช้ modern React patterns รวมถึง custom hooks, context API, protected routes และ axios interceptors เพื่อสร้าง scalable และ maintainable frontend application

<hr> #######################  <hr>

## การแยก Business Logic: Custom Hooks vs Services

การแยก business logic ออกจาก UI components เป็นหลักการสำคัญในการพัฒนา React applications ที่มีความ scalable และ maintainable  มีสองแนวทางหลัก: **Custom Hooks** สำหรับ logic ที่เกี่ยวข้องกับ React lifecycle และ **Services** สำหรับ pure business logic และ API calls[^1][^2][^3][^4]

## ความแตกต่างระหว่าง Custom Hooks และ Services

| Aspect | Custom Hooks | Services |
| :-- | :-- | :-- |
| **Purpose** | React-specific logic, state management | Pure business logic, API calls |
| **Can use React features** | ✅ useState, useEffect, useContext | ❌ Plain JavaScript functions |
| **Where to use** | Inside React components only | Anywhere (components, hooks, tests) |
| **Rerenders** | Can trigger component rerenders | No direct rerender capability |
| **Testability** | Requires React Testing Library | Easy to test with Jest alone |
| **Reusability** | Across React components | Across entire application |

## Architecture Pattern: 3-Layer Structure

```
┌─────────────────────────────────────┐
│       UI Layer (Components)         │  ← Presentation only
├─────────────────────────────────────┤
│    Business Logic (Custom Hooks)    │  ← React-aware logic
├─────────────────────────────────────┤
│    Data Layer (Services)            │  ← API calls, pure functions
└─────────────────────────────────────┘
```


## ตัวอย่างที่ 1: Booking Management

### Layer 1: Services (Data Layer)

**Booking Service** (`src/features/bookings/services/bookingService.js`)

```javascript
import api from '../../../services/api';

/**
 * Pure functions for API calls
 * No React dependencies, no state management
 * Easy to test, reusable anywhere
 */
const bookingService = {
  // Get all bookings
  getAllBookings: async () => {
    const response = await api.get('/bookings');
    return response.data;
  },

  // Get single booking by ID
  getBookingById: async (bookingId) => {
    const response = await api.get(`/bookings/${bookingId}`);
    return response.data;
  },

  // Create new booking
  createBooking: async (bookingData) => {
    const response = await api.post('/bookings', bookingData);
    return response.data;
  },

  // Update booking
  updateBooking: async (bookingId, updates) => {
    const response = await api.put(`/bookings/${bookingId}`, updates);
    return response.data;
  },

  // Cancel booking
  cancelBooking: async (bookingId, reason) => {
    const response = await api.post(`/bookings/${bookingId}/cancel`, {
      reason,
      cancelledAt: new Date().toISOString(),
    });
    return response.data;
  },

  // Check availability
  checkAvailability: async (date, serviceType) => {
    const response = await api.get('/bookings/availability', {
      params: { date, serviceType },
    });
    return response.data;
  },

  // Calculate price
  calculatePrice: (serviceType, vehicleType, additionalServices = []) => {
    const basePrices = {
      'oil-change': 800,
      'general-maintenance': 1500,
      'tire-change': 2000,
      'full-service': 3500,
    };

    const vehicleMultipliers = {
      'sedan': 1.0,
      'suv': 1.3,
      'truck': 1.5,
    };

    let total = basePrices[serviceType] || 0;
    total *= vehicleMultipliers[vehicleType] || 1.0;

    additionalServices.forEach((service) => {
      total += service.price;
    });

    return {
      basePrice: basePrices[serviceType],
      multiplier: vehicleMultipliers[vehicleType],
      additionalServicesTotal: additionalServices.reduce(
        (sum, s) => sum + s.price,
        0
      ),
      total,
    };
  },

  // Validate booking data
  validateBookingData: (data) => {
    const errors = {};

    if (!data.customerId) {
      errors.customerId = 'Customer ID is required';
    }

    if (!data.vehicleId) {
      errors.vehicleId = 'Vehicle ID is required';
    }

    if (!data.bookingDate) {
      errors.bookingDate = 'Booking date is required';
    } else {
      const bookingDate = new Date(data.bookingDate);
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      if (bookingDate < today) {
        errors.bookingDate = 'Cannot book in the past';
      }
    }

    if (!data.serviceType) {
      errors.serviceType = 'Service type is required';
    }

    return {
      isValid: Object.keys(errors).length === 0,
      errors,
    };
  },
};

export default bookingService;
```


### Layer 2: Custom Hooks (Business Logic Layer)

**useBookings Hook** (`src/features/bookings/hooks/useBookings.js`)

```javascript
import { useState, useEffect, useCallback } from 'react';
import bookingService from '../services/bookingService';
import { useAuth } from '../../auth/context/AuthContext';

/**
 * Custom hook for booking management
 * Handles React state, side effects, and lifecycle
 * Consumes bookingService for data operations
 */
const useBookings = () => {
  const { user } = useAuth();
  const [bookings, setBookings] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  // Fetch all bookings
  const fetchBookings = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const data = await bookingService.getAllBookings();
      setBookings(data);
    } catch (err) {
      setError(err.response?.data?.message || 'Failed to fetch bookings');
      console.error('Error fetching bookings:', err);
    } finally {
      setLoading(false);
    }
  }, []);

  // Load bookings on mount
  useEffect(() => {
    if (user) {
      fetchBookings();
    }
  }, [user, fetchBookings]);

  // Create booking with validation
  const createBooking = useCallback(async (bookingData) => {
    setLoading(true);
    setError(null);

    // Validate before sending
    const validation = bookingService.validateBookingData(bookingData);
    if (!validation.isValid) {
      setError('Please fix validation errors');
      setLoading(false);
      return { success: false, errors: validation.errors };
    }

    try {
      const newBooking = await bookingService.createBooking(bookingData);
      setBookings((prev) => [newBooking, ...prev]);
      return { success: true, data: newBooking };
    } catch (err) {
      const errorMessage = err.response?.data?.message || 'Failed to create booking';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, []);

  // Cancel booking
  const cancelBooking = useCallback(async (bookingId, reason) => {
    setLoading(true);
    setError(null);

    try {
      await bookingService.cancelBooking(bookingId, reason);
      
      // Update local state
      setBookings((prev) =>
        prev.map((booking) =>
          booking.id === bookingId
            ? { ...booking, status: 'cancelled', cancelReason: reason }
            : booking
        )
      );

      return { success: true };
    } catch (err) {
      const errorMessage = err.response?.data?.message || 'Failed to cancel booking';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, []);

  // Filter bookings by status
  const getBookingsByStatus = useCallback(
    (status) => {
      return bookings.filter((booking) => booking.status === status);
    },
    [bookings]
  );

  // Get upcoming bookings (within next 7 days)
  const getUpcomingBookings = useCallback(() => {
    const now = new Date();
    const sevenDaysLater = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);

    return bookings.filter((booking) => {
      const bookingDate = new Date(booking.bookingDate);
      return (
        bookingDate >= now &&
        bookingDate <= sevenDaysLater &&
        booking.status !== 'cancelled'
      );
    });
  }, [bookings]);

  return {
    bookings,
    loading,
    error,
    fetchBookings,
    createBooking,
    cancelBooking,
    getBookingsByStatus,
    getUpcomingBookings,
  };
};

export default useBookings;
```

**useBookingForm Hook** (`src/features/bookings/hooks/useBookingForm.js`)

```javascript
import { useState, useEffect } from 'react';
import bookingService from '../services/bookingService';
import { useAuth } from '../../auth/context/AuthContext';

/**
 * Custom hook for booking form logic
 * Handles form state, validation, and availability checking
 */
const useBookingForm = (initialData = {}) => {
  const { user } = useAuth();
  
  const [formData, setFormData] = useState({
    customerId: user?.id || '',
    vehicleId: '',
    bookingDate: '',
    serviceType: '',
    vehicleType: '',
    additionalServices: [],
    notes: '',
    ...initialData,
  });

  const [errors, setErrors] = useState({});
  const [priceBreakdown, setPriceBreakdown] = useState(null);
  const [availability, setAvailability] = useState(null);
  const [checkingAvailability, setCheckingAvailability] = useState(false);

  // Calculate price when relevant fields change
  useEffect(() => {
    if (formData.serviceType && formData.vehicleType) {
      const breakdown = bookingService.calculatePrice(
        formData.serviceType,
        formData.vehicleType,
        formData.additionalServices
      );
      setPriceBreakdown(breakdown);
    }
  }, [formData.serviceType, formData.vehicleType, formData.additionalServices]);

  // Check availability when date and service type change
  useEffect(() => {
    const checkAvailability = async () => {
      if (formData.bookingDate && formData.serviceType) {
        setCheckingAvailability(true);
        try {
          const result = await bookingService.checkAvailability(
            formData.bookingDate,
            formData.serviceType
          );
          setAvailability(result);
        } catch (error) {
          console.error('Failed to check availability:', error);
          setAvailability(null);
        } finally {
          setCheckingAvailability(false);
        }
      }
    };

    const debounceTimer = setTimeout(checkAvailability, 500);
    return () => clearTimeout(debounceTimer);
  }, [formData.bookingDate, formData.serviceType]);

  // Update form field
  const updateField = (field, value) => {
    setFormData((prev) => ({
      ...prev,
      [field]: value,
    }));

    // Clear error for this field
    if (errors[field]) {
      setErrors((prev) => {
        const newErrors = { ...prev };
        delete newErrors[field];
        return newErrors;
      });
    }
  };

  // Add additional service
  const addAdditionalService = (service) => {
    setFormData((prev) => ({
      ...prev,
      additionalServices: [...prev.additionalServices, service],
    }));
  };

  // Remove additional service
  const removeAdditionalService = (serviceId) => {
    setFormData((prev) => ({
      ...prev,
      additionalServices: prev.additionalServices.filter(
        (s) => s.id !== serviceId
      ),
    }));
  };

  // Validate form
  const validate = () => {
    const validation = bookingService.validateBookingData(formData);
    setErrors(validation.errors);
    return validation.isValid;
  };

  // Reset form
  const reset = () => {
    setFormData({
      customerId: user?.id || '',
      vehicleId: '',
      bookingDate: '',
      serviceType: '',
      vehicleType: '',
      additionalServices: [],
      notes: '',
    });
    setErrors({});
    setPriceBreakdown(null);
    setAvailability(null);
  };

  return {
    formData,
    errors,
    priceBreakdown,
    availability,
    checkingAvailability,
    updateField,
    addAdditionalService,
    removeAdditionalService,
    validate,
    reset,
  };
};

export default useBookingForm;
```


### Layer 3: UI Components

**BookingForm Component** (`src/features/bookings/components/BookingForm.jsx`)

```jsx
import { useState } from 'react';
import useBookings from '../hooks/useBookings';
import useBookingForm from '../hooks/useBookingForm';
import Button from '../../../components/common/Button/Button';
import Input from '../../../components/common/Input/Input';
import Select from '../../../components/common/Select/Select';
import './BookingForm.css';

/**
 * Pure UI component
 * No business logic, just presentation and event handling
 * Consumes custom hooks for all logic
 */
const BookingForm = ({ onSuccess }) => {
  const { createBooking, loading } = useBookings();
  const {
    formData,
    errors,
    priceBreakdown,
    availability,
    checkingAvailability,
    updateField,
    addAdditionalService,
    removeAdditionalService,
    validate,
    reset,
  } = useBookingForm();

  const [submitError, setSubmitError] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    setSubmitError('');

    if (!validate()) {
      setSubmitError('กรุณากรอกข้อมูลให้ครบถ้วน');
      return;
    }

    if (!availability?.isAvailable) {
      setSubmitError('ช่วงเวลาที่เลือกไม่ว่าง กรุณาเลือกวันอื่น');
      return;
    }

    const result = await createBooking(formData);

    if (result.success) {
      reset();
      onSuccess?.(result.data);
    } else {
      setSubmitError(result.error || 'ไม่สามารถสร้างการจองได้');
    }
  };

  return (
    <form className="booking-form" onSubmit={handleSubmit}>
      <h2>จองบริการ</h2>

      <Select
        label="ประเภทบริการ"
        value={formData.serviceType}
        onChange={(e) => updateField('serviceType', e.target.value)}
        error={errors.serviceType}
        required
      >
        <option value="">เลือกบริการ</option>
        <option value="oil-change">เปลี่ยนถ่ายน้ำมันเครื่อง</option>
        <option value="general-maintenance">ตรวจเช็คทั่วไป</option>
        <option value="tire-change">เปลี่ยนยาง</option>
        <option value="full-service">บริการเต็มรูปแบบ</option>
      </Select>

      <Select
        label="ประเภทรถยนต์"
        value={formData.vehicleType}
        onChange={(e) => updateField('vehicleType', e.target.value)}
        error={errors.vehicleType}
        required
      >
        <option value="">เลือกประเภทรถ</option>
        <option value="sedan">รถเก๋ง</option>
        <option value="suv">รถ SUV</option>
        <option value="truck">รถกระบะ</option>
      </Select>

      <Input
        type="date"
        label="วันที่จอง"
        value={formData.bookingDate}
        onChange={(e) => updateField('bookingDate', e.target.value)}
        error={errors.bookingDate}
        min={new Date().toISOString().split('T')[^0]}
        required
      />

      {/* Availability indicator */}
      {checkingAvailability && (
        <div className="availability-checking">กำลังตรวจสอบความพร้อม...</div>
      )}

      {availability && (
        <div
          className={`availability-status ${
            availability.isAvailable ? 'available' : 'unavailable'
          }`}
        >
          {availability.isAvailable ? (
            <>
              ✓ ช่วงเวลานี้ว่าง - มีช่องว่าง {availability.availableSlots} ช่อง
            </>
          ) : (
            <>✗ ช่วงเวลานี้เต็มแล้ว กรุณาเลือกวันอื่น</>
          )}
        </div>
      )}

      {/* Price breakdown */}
      {priceBreakdown && (
        <div className="price-breakdown">
          <h3>รายละเอียดราคา</h3>
          <div className="price-row">
            <span>ราคาพื้นฐาน:</span>
            <span>{priceBreakdown.basePrice.toLocaleString()} บาท</span>
          </div>
          <div className="price-row">
            <span>ตัวคูณตามประเภทรถ:</span>
            <span>×{priceBreakdown.multiplier}</span>
          </div>
          {priceBreakdown.additionalServicesTotal > 0 && (
            <div className="price-row">
              <span>บริการเสริม:</span>
              <span>
                {priceBreakdown.additionalServicesTotal.toLocaleString()} บาท
              </span>
            </div>
          )}
          <div className="price-row total">
            <span>รวมทั้งหมด:</span>
            <span>{priceBreakdown.total.toLocaleString()} บาท</span>
          </div>
        </div>
      )}

      <Input
        type="textarea"
        label="หมายเหตุ (ถ้ามี)"
        value={formData.notes}
        onChange={(e) => updateField('notes', e.target.value)}
        rows={4}
      />

      {submitError && <div className="error-message">{submitError}</div>}

      <div className="form-actions">
        <Button type="button" variant="secondary" onClick={reset}>
          ล้างข้อมูล
        </Button>
        <Button
          type="submit"
          loading={loading}
          disabled={loading || !availability?.isAvailable}
        >
          {loading ? 'กำลังจอง...' : 'ยืนยันการจอง'}
        </Button>
      </div>
    </form>
  );
};

export default BookingForm;
```


## ตัวอย่างที่ 2: Repair Tracking

### Service Layer

**Repair Service** (`src/features/repairs/services/repairService.js`)

```javascript
import api from '../../../services/api';

const repairService = {
  // Get repair details
  getRepairById: async (repairId) => {
    const response = await api.get(`/repairs/${repairId}`);
    return response.data;
  },

  // Get repairs by booking ID
  getRepairsByBooking: async (bookingId) => {
    const response = await api.get(`/repairs`, {
      params: { bookingId },
    });
    return response.data;
  },

  // Subscribe to repair status updates (WebSocket/SSE simulation)
  subscribeToUpdates: (repairId, callback) => {
    // In real app, this would use WebSocket or Server-Sent Events
    const eventSource = new EventSource(`/api/v1/repairs/${repairId}/stream`);
    
    eventSource.onmessage = (event) => {
      const data = JSON.parse(event.data);
      callback(data);
    };

    eventSource.onerror = (error) => {
      console.error('SSE Error:', error);
      eventSource.close();
    };

    // Return cleanup function
    return () => eventSource.close();
  },

  // Calculate repair progress percentage
  calculateProgress: (repair) => {
    const statusWeights = {
      'pending': 0,
      'diagnosed': 20,
      'parts-ordered': 40,
      'in-progress': 60,
      'testing': 80,
      'completed': 100,
    };

    return statusWeights[repair.status] || 0;
  },

  // Estimate completion time
  estimateCompletion: (repair) => {
    const now = new Date();
    const startTime = new Date(repair.startedAt);
    const estimatedDuration = repair.estimatedDuration; // in minutes

    const elapsedMinutes = (now - startTime) / (1000 * 60);
    const remainingMinutes = Math.max(0, estimatedDuration - elapsedMinutes);

    return {
      elapsed: Math.round(elapsedMinutes),
      remaining: Math.round(remainingMinutes),
      completionTime: new Date(now.getTime() + remainingMinutes * 60 * 1000),
    };
  },

  // Format status for display
  formatStatus: (status) => {
    const statusMap = {
      'pending': 'รอดำเนินการ',
      'diagnosed': 'ตรวจสอบแล้ว',
      'parts-ordered': 'สั่งอะไหล่แล้ว',
      'in-progress': 'กำลังซ่อม',
      'testing': 'ทดสอบ',
      'completed': 'เสร็จสิ้น',
    };

    return statusMap[status] || status;
  },
};

export default repairService;
```


### Custom Hook Layer

**useRepairTracking Hook** (`src/features/repairs/hooks/useRepairTracking.js`)

```javascript
import { useState, useEffect, useCallback, useRef } from 'react';
import repairService from '../services/repairService';

/**
 * Custom hook for real-time repair tracking
 * Manages WebSocket connection and live updates
 */
const useRepairTracking = (repairId) => {
  const [repair, setRepair] = useState(null);
  const [progress, setProgress] = useState(0);
  const [timeEstimate, setTimeEstimate] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isLive, setIsLive] = useState(false);
  
  const unsubscribeRef = useRef(null);

  // Fetch initial repair data
  const fetchRepair = useCallback(async () => {
    if (!repairId) return;

    setLoading(true);
    setError(null);

    try {
      const data = await repairService.getRepairById(repairId);
      setRepair(data);
      
      // Calculate derived data
      const progressPercent = repairService.calculateProgress(data);
      setProgress(progressPercent);

      if (data.status !== 'completed') {
        const estimate = repairService.estimateCompletion(data);
        setTimeEstimate(estimate);
      }
    } catch (err) {
      setError(err.response?.data?.message || 'Failed to fetch repair');
    } finally {
      setLoading(false);
    }
  }, [repairId]);

  // Subscribe to live updates
  useEffect(() => {
    if (!repairId || !repair) return;

    // Only subscribe if repair is not completed
    if (repair.status === 'completed') {
      setIsLive(false);
      return;
    }

    setIsLive(true);

    // Subscribe to updates
    unsubscribeRef.current = repairService.subscribeToUpdates(
      repairId,
      (update) => {
        setRepair((prev) => ({
          ...prev,
          ...update,
        }));

        // Recalculate progress
        const newProgress = repairService.calculateProgress(update);
        setProgress(newProgress);

        // Update time estimate
        if (update.status !== 'completed') {
          const estimate = repairService.estimateCompletion({
            ...repair,
            ...update,
          });
          setTimeEstimate(estimate);
        } else {
          setIsLive(false);
        }
      }
    );

    // Cleanup subscription on unmount
    return () => {
      if (unsubscribeRef.current) {
        unsubscribeRef.current();
      }
    };
  }, [repairId, repair]);

  // Update time estimate every minute
  useEffect(() => {
    if (!repair || repair.status === 'completed') return;

    const interval = setInterval(() => {
      const estimate = repairService.estimateCompletion(repair);
      setTimeEstimate(estimate);
    }, 60000); // Update every minute

    return () => clearInterval(interval);
  }, [repair]);

  // Load initial data
  useEffect(() => {
    fetchRepair();
  }, [fetchRepair]);

  return {
    repair,
    progress,
    timeEstimate,
    loading,
    error,
    isLive,
    refetch: fetchRepair,
  };
};

export default useRepairTracking;
```


### UI Component

**RepairStatusCard Component**

```jsx
import useRepairTracking from '../hooks/useRepairTracking';
import repairService from '../services/repairService';
import ProgressBar from '../../../components/common/ProgressBar/ProgressBar';
import './RepairStatusCard.css';

const RepairStatusCard = ({ repairId }) => {
  const {
    repair,
    progress,
    timeEstimate,
    loading,
    error,
    isLive,
  } = useRepairTracking(repairId);

  if (loading) return <div>กำลังโหลด...</div>;
  if (error) return <div>เกิดข้อผิดพลาด: {error}</div>;
  if (!repair) return <div>ไม่พบข้อมูลการซ่อม</div>;

  return (
    <div className="repair-status-card">
      {isLive && (
        <div className="live-indicator">
          <span className="pulse"></span>
          อัพเดทแบบ Real-time
        </div>
      )}

      <h3>สถานะการซ่อม</h3>
      
      <div className="status-badge">
        {repairService.formatStatus(repair.status)}
      </div>

      <ProgressBar value={progress} />

      {timeEstimate && (
        <div className="time-estimate">
          <p>เวลาที่ผ่านไป: {timeEstimate.elapsed} นาที</p>
          <p>เวลาที่เหลือ: {timeEstimate.remaining} นาที</p>
          <p>
            คาดว่าจะเสร็จ:{' '}
            {timeEstimate.completionTime.toLocaleTimeString('th-TH')}
          </p>
        </div>
      )}

      <div className="repair-details">
        <p><strong>ช่างผู้รับผิดชอบ:</strong> {repair.technician?.name}</p>
        <p><strong>ประเภทงาน:</strong> {repair.serviceType}</p>
        <p><strong>ค่าใช้จ่ายโดยประมาณ:</strong> {repair.estimatedCost} บาท</p>
      </div>
    </div>
  );
};

export default RepairStatusCard;
```

## สรุป Best Practices
### เมื่อใดควรใช้ Services
- ✅ API calls และ HTTP requests
- ✅ Pure business logic calculations
- ✅ Data transformation และ formatting
- ✅ Validation rules
- ✅ Constants และ configuration
- ✅ Logic ที่ต้องการใช้นอก React (tests, Node.js scripts)

### เมื่อใดควรใช้ Custom Hooks
- ✅ State management
- ✅ Side effects (useEffect)
- ✅ Lifecycle management
- ✅ Context consumption
- ✅ Combining multiple hooks
- ✅ React-specific logic
- ✅ Component rerender coordination

### ข้อดีของการแยก Logic

- ✅ Testability: Services ทดสอบง่ายด้วย Jest, Hooks ทดสอบด้วย React Testing Library แยกกันชัดเจน​
- ✅ Reusability: Services ใช้ได้ทุกที่, Hooks ใช้ได้ทุก React component​
- ✅ Maintainability: แก้ไข logic ในที่เดียว ไม่กระทบ UI components​
- ✅ Separation of Concerns: UI, Business Logic และ Data Layer แยกกันชัดเจน​
- ✅ การออกแบบแบบนี้ทำให้ codebase มีความเป็นระเบียบ ง่ายต่อการ debug และ scale ได้ดี
  

<hr> <hr> <hr> 

## วิธีทดสอบ Unit Test สำหรับ Custom Hooks และ Services

- การทดสอบ custom hooks และ services ต้องใช้เครื่องมือและวิธีการที่แตกต่างกัน โดย Services ทดสอบง่ายกว่าเพราะเป็น pure JavaScript functions ส่วน Custom Hooks ต้องใช้ React Testing Library

## การติดตั้ง Testing Libraries

```bash
# Install Jest and React Testing Library
npm install --save-dev jest @testing-library/react @testing-library/jest-dom @testing-library/user-event

# Install axios mock adapter (optional)
npm install --save-dev axios-mock-adapter jest-mock-extended
```


## ตัวอย่างที่ 1: Unit Testing Services

### Service Code

**bookingService.js**

```javascript
import api from '../../../services/api';

const bookingService = {
  getAllBookings: async () => {
    const response = await api.get('/bookings');
    return response.data;
  },

  createBooking: async (bookingData) => {
    const response = await api.post('/bookings', bookingData);
    return response.data;
  },

  calculatePrice: (serviceType, vehicleType, additionalServices = []) => {
    const basePrices = {
      'oil-change': 800,
      'general-maintenance': 1500,
      'tire-change': 2000,
      'full-service': 3500,
    };

    const vehicleMultipliers = {
      'sedan': 1.0,
      'suv': 1.3,
      'truck': 1.5,
    };

    let total = basePrices[serviceType] || 0;
    total *= vehicleMultipliers[vehicleType] || 1.0;

    additionalServices.forEach((service) => {
      total += service.price;
    });

    return {
      basePrice: basePrices[serviceType],
      multiplier: vehicleMultipliers[vehicleType],
      additionalServicesTotal: additionalServices.reduce(
        (sum, s) => sum + s.price,
        0
      ),
      total,
    };
  },

  validateBookingData: (data) => {
    const errors = {};

    if (!data.customerId) {
      errors.customerId = 'Customer ID is required';
    }

    if (!data.bookingDate) {
      errors.bookingDate = 'Booking date is required';
    } else {
      const bookingDate = new Date(data.bookingDate);
      const today = new Date();
      today.setHours(0, 0, 0, 0);

      if (bookingDate < today) {
        errors.bookingDate = 'Cannot book in the past';
      }
    }

    return {
      isValid: Object.keys(errors).length === 0,
      errors,
    };
  },
};

export default bookingService;
```


### Service Unit Tests

**bookingService.test.js**

```javascript
import bookingService from './bookingService';
import api from '../../../services/api';

// Mock the API module
jest.mock('../../../services/api');

describe('bookingService', () => {
  // Reset mocks before each test
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('getAllBookings', () => {
    it('should fetch all bookings successfully', async () => {
      // Arrange: Setup mock data
      const mockBookings = [
        { id: '1', customerId: 'c1', status: 'confirmed' },
        { id: '2', customerId: 'c2', status: 'pending' },
      ];

      // Mock axios response
      api.get.mockResolvedValue({ data: mockBookings });

      // Act: Call the service
      const result = await bookingService.getAllBookings();

      // Assert: Verify results
      expect(result).toEqual(mockBookings);
      expect(api.get).toHaveBeenCalledWith('/bookings');
      expect(api.get).toHaveBeenCalledTimes(1);
    });

    it('should handle errors when fetching bookings fails', async () => {
      // Arrange: Mock error response
      const errorMessage = 'Network Error';
      api.get.mockRejectedValue(new Error(errorMessage));

      // Act & Assert: Expect rejection
      await expect(bookingService.getAllBookings()).rejects.toThrow(
        errorMessage
      );
    });
  });

  describe('createBooking', () => {
    it('should create booking successfully', async () => {
      // Arrange
      const bookingData = {
        customerId: 'c1',
        vehicleId: 'v1',
        bookingDate: '2025-12-01',
        serviceType: 'oil-change',
      };

      const mockResponse = {
        id: 'b1',
        ...bookingData,
        status: 'pending',
      };

      api.post.mockResolvedValue({ data: mockResponse });

      // Act
      const result = await bookingService.createBooking(bookingData);

      // Assert
      expect(result).toEqual(mockResponse);
      expect(api.post).toHaveBeenCalledWith('/bookings', bookingData);
    });

    it('should handle validation errors from API', async () => {
      // Arrange
      const bookingData = { customerId: 'c1' };
      const errorResponse = {
        response: {
          status: 400,
          data: { message: 'Validation failed' },
        },
      };

      api.post.mockRejectedValue(errorResponse);

      // Act & Assert
      await expect(bookingService.createBooking(bookingData)).rejects.toEqual(
        errorResponse
      );
    });
  });

  describe('calculatePrice', () => {
    it('should calculate price for sedan oil change', () => {
      // Act
      const result = bookingService.calculatePrice('oil-change', 'sedan', []);

      // Assert
      expect(result).toEqual({
        basePrice: 800,
        multiplier: 1.0,
        additionalServicesTotal: 0,
        total: 800,
      });
    });

    it('should calculate price for SUV with multiplier', () => {
      // Act
      const result = bookingService.calculatePrice('oil-change', 'suv', []);

      // Assert
      expect(result).toEqual({
        basePrice: 800,
        multiplier: 1.3,
        additionalServicesTotal: 0,
        total: 1040, // 800 * 1.3
      });
    });

    it('should include additional services in total', () => {
      // Arrange
      const additionalServices = [
        { id: 's1', name: 'Air Filter', price: 200 },
        { id: 's2', name: 'Brake Check', price: 300 },
      ];

      // Act
      const result = bookingService.calculatePrice(
        'oil-change',
        'sedan',
        additionalServices
      );

      // Assert
      expect(result).toEqual({
        basePrice: 800,
        multiplier: 1.0,
        additionalServicesTotal: 500,
        total: 1300, // 800 + 200 + 300
      });
    });

    it('should handle unknown service type', () => {
      // Act
      const result = bookingService.calculatePrice('unknown', 'sedan', []);

      // Assert
      expect(result.total).toBe(0);
    });
  });

  describe('validateBookingData', () => {
    it('should validate correct booking data', () => {
      // Arrange
      const validData = {
        customerId: 'c1',
        vehicleId: 'v1',
        bookingDate: '2025-12-31',
        serviceType: 'oil-change',
      };

      // Act
      const result = bookingService.validateBookingData(validData);

      // Assert
      expect(result.isValid).toBe(true);
      expect(result.errors).toEqual({});
    });

    it('should return error when customerId is missing', () => {
      // Arrange
      const invalidData = {
        bookingDate: '2025-12-31',
      };

      // Act
      const result = bookingService.validateBookingData(invalidData);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.errors.customerId).toBe('Customer ID is required');
    });

    it('should return error when booking date is in the past', () => {
      // Arrange
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      
      const invalidData = {
        customerId: 'c1',
        bookingDate: yesterday.toISOString().split('T')[^0],
      };

      // Act
      const result = bookingService.validateBookingData(invalidData);

      // Assert
      expect(result.isValid).toBe(false);
      expect(result.errors.bookingDate).toBe('Cannot book in the past');
    });

    it('should return multiple errors for multiple issues', () => {
      // Arrange
      const invalidData = {};

      // Act
      const result = bookingService.validateBookingData(invalidData);

      // Assert
      expect(result.isValid).toBe(false);
      expect(Object.keys(result.errors).length).toBeGreaterThan(1);
    });
  });
});
```


## ตัวอย่างที่ 2: Unit Testing Custom Hooks

### Custom Hook Code

**useBookings.js**

```javascript
import { useState, useEffect, useCallback } from 'react';
import bookingService from '../services/bookingService';

const useBookings = () => {
  const [bookings, setBookings] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchBookings = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const data = await bookingService.getAllBookings();
      setBookings(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchBookings();
  }, [fetchBookings]);

  const createBooking = useCallback(async (bookingData) => {
    setLoading(true);
    setError(null);

    try {
      const newBooking = await bookingService.createBooking(bookingData);
      setBookings((prev) => [newBooking, ...prev]);
      return { success: true, data: newBooking };
    } catch (err) {
      setError(err.message);
      return { success: false, error: err.message };
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    bookings,
    loading,
    error,
    fetchBookings,
    createBooking,
  };
};

export default useBookings;
```


### Custom Hook Unit Tests

**useBookings.test.js**

```javascript
import { renderHook, waitFor, act } from '@testing-library/react';
import useBookings from './useBookings';
import bookingService from '../services/bookingService';

// Mock the service
jest.mock('../services/bookingService');

describe('useBookings', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should initialize with empty state', () => {
    // Arrange
    bookingService.getAllBookings.mockResolvedValue([]);

    // Act
    const { result } = renderHook(() => useBookings());

    // Assert
    expect(result.current.bookings).toEqual([]);
    expect(result.current.loading).toBe(true); // Initially loading
    expect(result.current.error).toBe(null);
  });

  it('should fetch bookings on mount', async () => {
    // Arrange
    const mockBookings = [
      { id: '1', customerId: 'c1', status: 'confirmed' },
      { id: '2', customerId: 'c2', status: 'pending' },
    ];
    bookingService.getAllBookings.mockResolvedValue(mockBookings);

    // Act
    const { result } = renderHook(() => useBookings());

    // Assert - Wait for async operation to complete
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.bookings).toEqual(mockBookings);
    expect(result.current.error).toBe(null);
    expect(bookingService.getAllBookings).toHaveBeenCalledTimes(1);
  });

  it('should handle fetch errors', async () => {
    // Arrange
    const errorMessage = 'Failed to fetch bookings';
    bookingService.getAllBookings.mockRejectedValue(
      new Error(errorMessage)
    );

    // Act
    const { result } = renderHook(() => useBookings());

    // Assert
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    expect(result.current.bookings).toEqual([]);
    expect(result.current.error).toBe(errorMessage);
  });

  it('should create booking successfully', async () => {
    // Arrange
    bookingService.getAllBookings.mockResolvedValue([]);
    
    const newBookingData = {
      customerId: 'c1',
      vehicleId: 'v1',
      bookingDate: '2025-12-31',
    };

    const mockNewBooking = {
      id: 'b1',
      ...newBookingData,
      status: 'pending',
    };

    bookingService.createBooking.mockResolvedValue(mockNewBooking);

    // Act
    const { result } = renderHook(() => useBookings());

    // Wait for initial fetch
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    let createResult;
    await act(async () => {
      createResult = await result.current.createBooking(newBookingData);
    });

    // Assert
    expect(createResult.success).toBe(true);
    expect(createResult.data).toEqual(mockNewBooking);
    expect(result.current.bookings).toHaveLength(1);
    expect(result.current.bookings[^0]).toEqual(mockNewBooking);
    expect(bookingService.createBooking).toHaveBeenCalledWith(newBookingData);
  });

  it('should handle create booking errors', async () => {
    // Arrange
    bookingService.getAllBookings.mockResolvedValue([]);
    const errorMessage = 'Validation failed';
    bookingService.createBooking.mockRejectedValue(new Error(errorMessage));

    // Act
    const { result } = renderHook(() => useBookings());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });

    let createResult;
    await act(async () => {
      createResult = await result.current.createBooking({});
    });

    // Assert
    expect(createResult.success).toBe(false);
    expect(createResult.error).toBe(errorMessage);
    expect(result.current.error).toBe(errorMessage);
    expect(result.current.bookings).toHaveLength(0);
  });

  it('should refetch bookings when fetchBookings is called', async () => {
    // Arrange
    const initialBookings = [{ id: '1', status: 'pending' }];
    const updatedBookings = [
      { id: '1', status: 'confirmed' },
      { id: '2', status: 'pending' },
    ];

    bookingService.getAllBookings
      .mockResolvedValueOnce(initialBookings)
      .mockResolvedValueOnce(updatedBookings);

    // Act
    const { result } = renderHook(() => useBookings());

    await waitFor(() => {
      expect(result.current.bookings).toEqual(initialBookings);
    });

    // Call refetch
    await act(async () => {
      await result.current.fetchBookings();
    });

    // Assert
    expect(result.current.bookings).toEqual(updatedBookings);
    expect(bookingService.getAllBookings).toHaveBeenCalledTimes(2);
  });
});
```


## ตัวอย่างที่ 3: Testing Authentication with localStorage

### Auth Service

**authService.js**

```javascript
import api from '../../../services/api';

const authService = {
  login: async (email, password) => {
    const response = await api.post('/auth/login', { email, password });
    const { token, user } = response.data;
    
    localStorage.setItem('token', token);
    localStorage.setItem('user', JSON.stringify(user));
    
    return response.data;
  },

  logout: () => {
    localStorage.removeItem('token');
    localStorage.removeItem('user');
  },

  getToken: () => {
    return localStorage.getItem('token');
  },

  isAuthenticated: () => {
    return !!localStorage.getItem('token');
  },
};

export default authService;
```


### Auth Service Tests with localStorage Mock

**authService.test.js**

```javascript
import authService from './authService';
import api from '../../../services/api';

// Mock API
jest.mock('../../../services/api');

// Mock localStorage
const localStorageMock = (() => {
  let store = {};

  return {
    getItem: jest.fn((key) => store[key] || null),
    setItem: jest.fn((key, value) => {
      store[key] = value.toString();
    }),
    removeItem: jest.fn((key) => {
      delete store[key];
    }),
    clear: jest.fn(() => {
      store = {};
    }),
  };
})();

// Replace global localStorage with mock
Object.defineProperty(window, 'localStorage', {
  value: localStorageMock,
});

describe('authService', () => {
  beforeEach(() => {
    // Clear all mocks before each test
    jest.clearAllMocks();
    localStorageMock.clear();
  });

  describe('login', () => {
    it('should login successfully and store token', async () => {
      // Arrange
      const mockResponse = {
        token: 'mock-jwt-token',
        user: { id: 'u1', email: 'test@example.com', name: 'Test User' },
      };

      api.post.mockResolvedValue({ data: mockResponse });

      // Act
      const result = await authService.login('test@example.com', 'password123');

      // Assert
      expect(result).toEqual(mockResponse);
      expect(api.post).toHaveBeenCalledWith('/auth/login', {
        email: 'test@example.com',
        password: 'password123',
      });
      
      expect(localStorageMock.setItem).toHaveBeenCalledWith(
        'token',
        'mock-jwt-token'
      );
      expect(localStorageMock.setItem).toHaveBeenCalledWith(
        'user',
        JSON.stringify(mockResponse.user)
      );
    });

    it('should handle login errors', async () => {
      // Arrange
      const errorResponse = {
        response: {
          status: 401,
          data: { message: 'Invalid credentials' },
        },
      };

      api.post.mockRejectedValue(errorResponse);

      // Act & Assert
      await expect(
        authService.login('test@example.com', 'wrongpassword')
      ).rejects.toEqual(errorResponse);

      expect(localStorageMock.setItem).not.toHaveBeenCalled();
    });
  });

  describe('logout', () => {
    it('should remove token and user from localStorage', () => {
      // Arrange
      localStorageMock.setItem('token', 'mock-token');
      localStorageMock.setItem('user', JSON.stringify({ id: 'u1' }));

      // Act
      authService.logout();

      // Assert
      expect(localStorageMock.removeItem).toHaveBeenCalledWith('token');
      expect(localStorageMock.removeItem).toHaveBeenCalledWith('user');
    });
  });

  describe('getToken', () => {
    it('should return token from localStorage', () => {
      // Arrange
      const mockToken = 'mock-jwt-token';
      localStorageMock.setItem('token', mockToken);

      // Act
      const result = authService.getToken();

      // Assert
      expect(result).toBe(mockToken);
      expect(localStorageMock.getItem).toHaveBeenCalledWith('token');
    });

    it('should return null when no token exists', () => {
      // Act
      const result = authService.getToken();

      // Assert
      expect(result).toBeNull();
    });
  });

  describe('isAuthenticated', () => {
    it('should return true when token exists', () => {
      // Arrange
      localStorageMock.setItem('token', 'mock-token');

      // Act
      const result = authService.isAuthenticated();

      // Assert
      expect(result).toBe(true);
    });

    it('should return false when no token exists', () => {
      // Act
      const result = authService.isAuthenticated();

      // Assert
      expect(result).toBe(false);
    });
  });
});
```


## Best Practices สำหรับการทดสอบ

### 1. AAA Pattern (Arrange-Act-Assert)

```javascript
it('should do something', () => {
  // Arrange: Set up test data and mocks
  const input = { /* ... */ };
  service.method.mockResolvedValue(expectedOutput);
  
  // Act: Execute the code under test
  const result = functionUnderTest(input);
  
  // Assert: Verify the results
  expect(result).toEqual(expectedOutput);
  expect(service.method).toHaveBeenCalledWith(input);
});
```


### 2. ใช้ describe เพื่อจัดกลุ่ม Tests

```javascript
describe('bookingService', () => {
  describe('getAllBookings', () => {
    it('should handle success case', () => { /* ... */ });
    it('should handle error case', () => { /* ... */ });
  });
  
  describe('createBooking', () => {
    it('should create successfully', () => { /* ... */ });
  });
});
```


### 3. Clean Up After Each Test

```javascript
beforeEach(() => {
  jest.clearAllMocks(); // Clear mock call history
  localStorage.clear(); // Clear localStorage
});

afterEach(() => {
  jest.restoreAllMocks(); // Restore original implementations
});
```


### 4. Test Edge Cases

```javascript
it('should handle empty array', () => { /* ... */ });
it('should handle null input', () => { /* ... */ });
it('should handle undefined values', () => { /* ... */ });
it('should handle network timeout', () => { /* ... */ });
```


### 5. ใช้ waitFor สำหรับ Async Operations

```javascript
await waitFor(() => {
  expect(result.current.loading).toBe(false);
});

await waitFor(() => {
  expect(result.current.data).toBeDefined();
}, { timeout: 3000 });
```


## Package.json Configuration

```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:verbose": "jest --verbose"
  },
  "jest": {
    "testEnvironment": "jsdom",
    "setupFilesAfterEnv": ["<rootDir>/src/setupTests.js"],
    "moduleNameMapper": {
      "\\.(css|less|scss|sass)$": "identity-obj-proxy"
    },
    "collectCoverageFrom": [
      "src/**/*.{js,jsx}",
      "!src/index.js",
      "!src/reportWebVitals.js"
    ],
    "coverageThreshold": {
      "global": {
        "branches": 80,
        "functions": 80,
        "lines": 80,
        "statements": 80
      }
    }
  }
}
```


## สรุปความแตกต่างการทดสอบ

| Aspect | Services | Custom Hooks |
| :-- | :-- | :-- |
| **Testing Tool** | Jest only | Jest + React Testing Library |
| **Render Required** | ❌ No | ✅ Yes (renderHook) |
| **Use act()** | ❌ No | ✅ Yes for state updates |
| **Use waitFor()** | ❌ No (use async/await) | ✅ Yes for async operations |
| **Mock Dependencies** | API, localStorage | Services, Context |
| **Complexity** | Simple | More complex |

การทดสอบ Services ง่ายกว่าเพราะเป็น pure functions ไม่มี React dependencies  ส่วน Custom Hooks ต้องใช้ `renderHook()` และ `act()` เพื่อจำลอง React environment

<hr> <hr> <hr> 


## การออกแบบ Git Flow สำหรับโปรเจกต์ระบบศูนย์บริการรถยนต์

สำหรับโปรเจกต์นี้ที่มีทั้ง Backend (NestJS + Spring Boot) และ Frontend (ReactJS) แนะนำให้ใช้ **Modified Git Flow** ที่ผสมผสานความเข้มงวดของ Git Flow กับความคล่องตัวของ GitHub Flow เพื่อรองรับ microservices architecture[^1][^2]

## โครงสร้าง Repository

### Option 1: Monorepo  

```
car-service-system/
├── backend/
│   ├── nestjs-api/          # NestJS API Service
│   ├── spring-boot-api/     # Spring Boot + Kafka Service
│   └── shared/              # Shared types, utilities
├── frontend/
│   └── react-app/           # ReactJS Application
├── infrastructure/
│   ├── docker/              # Docker configurations
│   ├── kubernetes/          # K8s manifests
│   └── terraform/           # Infrastructure as Code
├── docs/                    # Documentation
└── scripts/                 # Deployment scripts
```

**ข้อดีของ Monorepo:**

- เปลี่ยนแปลงหลายส่วนใน PR เดียว (เช่น เพิ่ม API endpoint และ UI พร้อมกัน)
- Dependency management ง่ายกว่า
- Integration testing สะดวก
- Version control แบบ atomic
[^3][^4]


### Option 2: Multi-Repo (ทีมใหญ่)

```
Repositories:
- car-service-nestjs-api
- car-service-spring-boot-api  
- car-service-frontend
- car-service-infrastructure
```


## Git Flow Structure

### Branch Strategy

```
main (production)
├── develop (integration)
│   ├── feature/booking-system
│   ├── feature/repair-tracking
│   ├── feature/payment-integration
│   └── feature/notification-service
├── release/v1.0.0
│   └── release/v1.1.0
└── hotfix/fix-payment-bug
```


### Branch Types และ Naming Conventions

| Branch Type | Naming Pattern | Purpose | Merge To |
| :-- | :-- | :-- | :-- |
| **main** | `main` | Production-ready code | - |
| **develop** | `develop` | Integration branch | main (via release) |
| **feature** | `feature/[ticket]-[description]` | New features | develop |
| **bugfix** | `bugfix/[ticket]-[description]` | Bug fixes | develop |
| **release** | `release/v[major].[minor].[patch]` | Release preparation | main + develop |
| **hotfix** | `hotfix/[ticket]-[description]` | Production fixes | main + develop |



### Branch Naming Examples

```bash
# Features
feature/CAR-123-booking-api
feature/CAR-124-jwt-authentication
feature/CAR-125-kafka-integration
feature/CAR-126-booking-form-ui

# Bug fixes
bugfix/CAR-201-fix-booking-validation
bugfix/CAR-202-cache-invalidation-issue

# Releases
release/v1.0.0
release/v1.1.0

# Hotfixes
hotfix/CAR-301-fix-payment-timeout
hotfix/CAR-302-security-patch
```


## Workflow Diagram

```
┌──────────────────────────────────────────────────────────────┐
│                         MAIN BRANCH                           │
│                    (Production Ready)                         │
└────┬──────────────────────────────────────────────┬──────────┘
     │                                               │
     │ Hotfix                                   Release Merge
     │                                               │
┌────┴───────────┐                           ┌──────┴──────────┐
│ hotfix/fix-xxx │                           │ release/v1.0.0  │
└────┬───────────┘                           └──────┬──────────┘
     │                                               │
     │ Merge back                                    │ Merge
     │                                               │
┌────┴───────────────────────────────────────────────┴─────────┐
│                      DEVELOP BRANCH                           │
│                  (Integration Branch)                         │
└────┬────────┬────────┬────────┬────────┬────────┬───────────┘
     │        │        │        │        │        │
     │        │        │        │        │        │
┌────┴────┐ ┌┴────┐  ┌┴─────┐ ┌┴──────┐┌┴──────┐ ┌┴──────────┐
│ feature │ │feat.│  │bugfix│ │feature││bugfix │ │ feature   │
│ /booking│ │/auth│  │/cache│ │/kafka ││/valid.│ │ /payment  │
└─────────┘ └─────┘  └──────┘ └───────┘└───────┘ └───────────┘
```


## Complete Workflow

### 1. Feature Development Workflow

```bash
# 1. Create feature branch from develop
git checkout develop
git pull origin develop
git checkout -b feature/CAR-123-booking-api

# 2. Work on feature (commit often)
git add .
git commit -m "feat(booking): add booking API endpoint"
git commit -m "feat(booking): implement validation logic"
git commit -m "test(booking): add unit tests for booking service"

# 3. Keep feature branch updated with develop
git fetch origin
git rebase origin/develop

# 4. Push feature branch
git push origin feature/CAR-123-booking-api

# 5. Create Pull Request (PR)
# - Go to GitHub/GitLab
# - Create PR from feature/CAR-123-booking-api → develop
# - Add reviewers
# - Link JIRA ticket

# 6. After PR approval, merge to develop
# - Squash and merge (clean history)
# - Delete feature branch
```


### 2. Release Workflow

```bash
# 1. Create release branch from develop
git checkout develop
git pull origin develop
git checkout -b release/v1.0.0

# 2. Update version numbers
# - package.json (frontend)
# - pom.xml / build.gradle (Spring Boot)
# - package.json (NestJS)
npm version 1.0.0
git commit -m "chore: bump version to 1.0.0"

# 3. Final testing and bug fixes on release branch
git commit -m "fix(release): minor UI adjustments"
git commit -m "docs: update changelog for v1.0.0"

# 4. Merge to main (production)
git checkout main
git merge --no-ff release/v1.0.0
git tag -a v1.0.0 -m "Release version 1.0.0"
git push origin main --tags

# 5. Merge back to develop
git checkout develop
git merge --no-ff release/v1.0.0
git push origin develop

# 6. Delete release branch
git branch -d release/v1.0.0
git push origin --delete release/v1.0.0
```


### 3. Hotfix Workflow

```bash
# 1. Create hotfix branch from main
git checkout main
git pull origin main
git checkout -b hotfix/CAR-301-fix-payment-timeout

# 2. Fix the critical bug
git add .
git commit -m "fix(payment): increase timeout to 30 seconds"
git commit -m "test(payment): add timeout test case"

# 3. Bump patch version
npm version patch  # 1.0.0 → 1.0.1

# 4. Merge to main
git checkout main
git merge --no-ff hotfix/CAR-301-fix-payment-timeout
git tag -a v1.0.1 -m "Hotfix: Fix payment timeout"
git push origin main --tags

# 5. Merge to develop
git checkout develop
git merge --no-ff hotfix/CAR-301-fix-payment-timeout
git push origin develop

# 6. Delete hotfix branch
git branch -d hotfix/CAR-301-fix-payment-timeout
git push origin --delete hotfix/CAR-301-fix-payment-timeout
```


## Commit Message Convention

### Conventional Commits Format

```
<type>(<scope>): <subject>

<body>

<footer>
```


### Commit Types

```bash
feat:     # New feature
fix:      # Bug fix
docs:     # Documentation changes
style:    # Code style changes (formatting, semicolons)
refactor: # Code refactoring
perf:     # Performance improvements
test:     # Adding or updating tests
chore:    # Build process or auxiliary tool changes
ci:       # CI/CD configuration changes
```


### Commit Examples

```bash
# Feature
git commit -m "feat(booking): add booking creation API endpoint"
git commit -m "feat(auth): implement JWT authentication"

# Bug fix
git commit -m "fix(booking): resolve date validation issue"
git commit -m "fix(cache): correct Redis cache invalidation logic"

# Documentation
git commit -m "docs(api): update API documentation for bookings"

# Testing
git commit -m "test(booking): add integration tests for booking service"

# Breaking changes
git commit -m "feat(api)!: change booking API response format

BREAKING CHANGE: Response now includes metadata field"
```


## Pull Request (PR) Guidelines

### PR Template

```markdown
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix (non-breaking change)
- [ ] New feature (non-breaking change)
- [ ] Breaking change
- [ ] Documentation update

## Related Issues
Closes #123
Related to #456

## Changes Made
- Added booking API endpoint
- Implemented JWT authentication
- Updated database schema

## Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-review completed
- [ ] Comments added for complex logic
- [ ] Documentation updated
- [ ] No new warnings generated

## Screenshots (if applicable)
[Add screenshots here]

## Deployment Notes
- Requires database migration
- Environment variables need updating
```


### PR Review Process

1. **Developer** creates PR with detailed description
2. **Automated Checks** run (CI/CD pipeline)
    - Linting
    - Unit tests
    - Integration tests
    - Code coverage
3. **Code Review** by 2+ team members
4. **Changes Requested** (if needed)
5. **Approval** from reviewers
6. **Merge** to target branch
7. **Automatic Deployment** (if configured)

[^2][^5]

## Branch Protection Rules

### Main Branch Protection

```yaml
Branch: main
Rules:
  - Require pull request reviews: 2 approvals
  - Require status checks to pass: true
    - CI/CD pipeline
    - Unit tests
    - Integration tests
    - Code coverage ≥ 80%
  - Require branches to be up to date: true
  - Include administrators: true
  - Restrict who can push: Only via PR
  - Require linear history: true
```


### Develop Branch Protection

```yaml
Branch: develop
Rules:
  - Require pull request reviews: 1 approval
  - Require status checks to pass: true
    - Linting
    - Unit tests
  - Require branches to be up to date: true
  - Allow force pushes: false
```


## CI/CD Integration

### GitHub Actions Workflow Example

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  # Backend NestJS
  nestjs-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: cd backend/nestjs-api && npm ci
      - run: cd backend/nestjs-api && npm run lint
      - run: cd backend/nestjs-api && npm test
      - run: cd backend/nestjs-api && npm run test:e2e

  # Backend Spring Boot
  spring-boot-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '17'
      - run: cd backend/spring-boot-api && ./mvnw test

  # Frontend React
  frontend-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
      - run: cd frontend/react-app && npm ci
      - run: cd frontend/react-app && npm run lint
      - run: cd frontend/react-app && npm test -- --coverage

  # Deploy to staging (on develop)
  deploy-staging:
    needs: [nestjs-test, spring-boot-test, frontend-test]
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Staging
        run: ./scripts/deploy-staging.sh

  # Deploy to production (on main)
  deploy-production:
    needs: [nestjs-test, spring-boot-test, frontend-test]
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Production
        run: ./scripts/deploy-production.sh
```


## Monorepo Change Detection

```yaml
# Detect changes and deploy only affected services
detect-changes:
  runs-on: ubuntu-latest
  outputs:
    nestjs: ${{ steps.changes.outputs.nestjs }}
    spring: ${{ steps.changes.outputs.spring }}
    frontend: ${{ steps.changes.outputs.frontend }}
  steps:
    - uses: actions/checkout@v3
    - uses: dorny/paths-filter@v2
      id: changes
      with:
        filters: |
          nestjs:
            - 'backend/nestjs-api/**'
          spring:
            - 'backend/spring-boot-api/**'
          frontend:
            - 'frontend/react-app/**'
```


## Best Practices Summary

### Do's ✅

- **Keep branches short-lived** (< 2 weeks)
- **Commit frequently** with meaningful messages
- **Rebase before merge** to keep history clean
- **Write descriptive PR descriptions**
- **Request code reviews** from 2+ people
- **Run tests locally** before pushing
- **Update documentation** with code changes
- **Use branch protection** rules
- **Tag releases** with semantic versioning
- **Delete merged branches** to keep repo clean


### Don'ts ❌

- ❌ Don't commit directly to main/develop
- ❌ Don't push broken code
- ❌ Don't merge without PR review
- ❌ Don't use generic commit messages ("fix", "update")
- ❌ Don't leave PRs open for too long
- ❌ Don't mix unrelated changes in one commit
- ❌ Don't force push to shared branches
- ❌ Don't merge with failing tests



## Team Workflow Summary

```
Developer → Create Feature Branch → Work on Feature
    ↓
Commit Changes → Push to Remote → Create PR
    ↓
Code Review → Automated Tests → Address Feedback
    ↓
Approval → Merge to Develop → Delete Feature Branch
    ↓
Weekly/Sprint Release → Create Release Branch → Test
    ↓
Merge to Main → Tag Version → Deploy to Production
    ↓
Merge Release back to Develop → Continue Development
```

Git Flow นี้ให้ความสมดุลระหว่าง structure และ flexibility เหมาะสำหรับทีมขนาดกลางถึงใหญ่ที่ต้องการ quality control แต่ยังคงความคล่องตัวในการพัฒนา



<hr><hr><hr><hr>
## การออกแบบ CI/CD Workflow สอดคล้องกับ Git Flow

ระบบ CI/CD ที่ออกแบบนี้จะรองรับ Git Flow โดยมี 3 environments หลัก (Development, Staging, Production) และใช้ GitHub Actions เป็นตัวอย่าง[^1][^2]

## สถาปัตยกรรม CI/CD Overview

```
┌─────────────────────────────────────────────────────────────┐
│                     GIT FLOW BRANCHES                        │
├──────────────┬──────────────┬──────────────┬────────────────┤
│   Feature    │   Develop    │   Release    │     Main       │
│   Branches   │              │   Branches   │  (Production)  │
└──────┬───────┴──────┬───────┴──────┬───────┴────────┬───────┘
       │              │              │                │
       ▼              ▼              ▼                ▼
┌──────────────┬──────────────┬──────────────┬────────────────┐
│   CI: Test   │  CI + Deploy │  CI + Deploy │  CI + Deploy   │
│   Only       │  to Dev      │  to Staging  │  to Production │
└──────────────┴──────────────┴──────────────┴────────────────┘
       │              │              │                │
       ▼              ▼              ▼                ▼
┌──────────────┬──────────────┬──────────────┬────────────────┐
│  No Deploy   │ Development  │   Staging    │   Production   │
│              │ Environment  │ Environment  │  Environment   │
└──────────────┴──────────────┴──────────────┴────────────────┘
```


## Environment Configuration

### Environment Matrix

| Environment | Branch | Auto Deploy | Approval Required | Database | URL |
| :-- | :-- | :-- | :-- | :-- | :-- |
| **Development** | `develop` | ✅ Yes | ❌ No | Dev DB | `dev.car-service.com` |
| **Staging** | `release/*` | ✅ Yes | ❌ No | Staging DB | `staging.car-service.com` |
| **Production** | `main` | ⚠️ Manual | ✅ Yes (2 approvers) | Prod DB | `car-service.com` |

[^6][^3]

## Complete GitHub Actions Workflow

### Main CI/CD Pipeline

**.github/workflows/ci-cd.yml**

```yaml
name: Car Service CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
      - 'release/**'
  pull_request:
    branches:
      - main
      - develop

env:
  REGISTRY: docker.io
  NESTJS_IMAGE: your-org/car-service-nestjs
  SPRING_IMAGE: your-org/car-service-spring
  FRONTEND_IMAGE: your-org/car-service-frontend
  NODE_VERSION: '18'
  JAVA_VERSION: '17'

jobs:
  # ==================== DETECT CHANGES ====================
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      nestjs: ${{ steps.filter.outputs.nestjs }}
      spring: ${{ steps.filter.outputs.spring }}
      frontend: ${{ steps.filter.outputs.frontend }}
      infra: ${{ steps.filter.outputs.infra }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: dorny/paths-filter@v2
        id: filter
        with:
          filters: |
            nestjs:
              - 'backend/nestjs-api/**'
            spring:
              - 'backend/spring-boot-api/**'
            frontend:
              - 'frontend/react-app/**'
            infra:
              - 'infrastructure/**'

  # ==================== NESTJS CI ====================
  nestjs-ci:
    needs: detect-changes
    if: needs.detect-changes.outputs.nestjs == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: backend/nestjs-api/package-lock.json

      - name: Install dependencies
        working-directory: backend/nestjs-api
        run: npm ci

      - name: Lint code
        working-directory: backend/nestjs-api
        run: npm run lint

      - name: Run unit tests
        working-directory: backend/nestjs-api
        run: npm run test:cov

      - name: Run e2e tests
        working-directory: backend/nestjs-api
        run: npm run test:e2e

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./backend/nestjs-api/coverage/coverage-final.json
          flags: nestjs
          name: nestjs-coverage

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          projectBaseDir: backend/nestjs-api

  # ==================== SPRING BOOT CI ====================
  spring-boot-ci:
    needs: detect-changes
    if: needs.detect-changes.outputs.spring == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      - name: Build with Maven
        working-directory: backend/spring-boot-api
        run: mvn clean install -DskipTests

      - name: Run unit tests
        working-directory: backend/spring-boot-api
        run: mvn test

      - name: Run integration tests
        working-directory: backend/spring-boot-api
        run: mvn verify

      - name: Generate test report
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: Spring Boot Tests
          path: backend/spring-boot-api/target/surefire-reports/*.xml
          reporter: java-junit

      - name: Code coverage
        working-directory: backend/spring-boot-api
        run: mvn jacoco:report

  # ==================== FRONTEND CI ====================
  frontend-ci:
    needs: detect-changes
    if: needs.detect-changes.outputs.frontend == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/react-app/package-lock.json

      - name: Install dependencies
        working-directory: frontend/react-app
        run: npm ci

      - name: Lint code
        working-directory: frontend/react-app
        run: npm run lint

      - name: Run tests
        working-directory: frontend/react-app
        run: npm test -- --coverage --watchAll=false

      - name: Build production
        working-directory: frontend/react-app
        run: npm run build
        env:
          VITE_API_URL: ${{ secrets.API_URL }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: frontend-build
          path: frontend/react-app/dist
          retention-days: 7

  # ==================== SECURITY SCANNING ====================
  security-scan:
    needs: [detect-changes]
    if: |
      needs.detect-changes.outputs.nestjs == 'true' ||
      needs.detect-changes.outputs.spring == 'true' ||
      needs.detect-changes.outputs.frontend == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # ==================== BUILD & PUSH DOCKER IMAGES ====================
  build-images:
    needs: [nestjs-ci, spring-boot-ci, frontend-ci, detect-changes]
    if: |
      always() &&
      (github.ref == 'refs/heads/develop' || 
       github.ref == 'refs/heads/main' ||
       startsWith(github.ref, 'refs/heads/release/'))
    runs-on: ubuntu-latest

    strategy:
      matrix:
        service:
          - name: nestjs
            path: backend/nestjs-api
            image: ${{ env.NESTJS_IMAGE }}
            condition: needs.detect-changes.outputs.nestjs == 'true'
          - name: spring
            path: backend/spring-boot-api
            image: ${{ env.SPRING_IMAGE }}
            condition: needs.detect-changes.outputs.spring == 'true'
          - name: frontend
            path: frontend/react-app
            image: ${{ env.FRONTEND_IMAGE }}
            condition: needs.detect-changes.outputs.frontend == 'true'

    steps:
      - name: Checkout code
        if: ${{ matrix.service.condition }}
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        if: ${{ matrix.service.condition }}
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        if: ${{ matrix.service.condition }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        if: ${{ matrix.service.condition }}
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ matrix.service.image }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=semver,pattern={{version}}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push
        if: ${{ matrix.service.condition }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.service.path }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ matrix.service.image }}:buildcache
          cache-to: type=registry,ref=${{ matrix.service.image }}:buildcache,mode=max

  # ==================== DEPLOY TO DEVELOPMENT ====================
  deploy-dev:
    needs: [build-images]
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    environment:
      name: development
      url: https://dev.car-service.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_DEV }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy to Kubernetes
        run: |
          kubectl set image deployment/nestjs-api \
            nestjs-api=${{ env.NESTJS_IMAGE }}:develop-${{ github.sha }} \
            -n development
          
          kubectl set image deployment/spring-api \
            spring-api=${{ env.SPRING_IMAGE }}:develop-${{ github.sha }} \
            -n development
          
          kubectl set image deployment/frontend \
            frontend=${{ env.FRONTEND_IMAGE }}:develop-${{ github.sha }} \
            -n development

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/nestjs-api -n development
          kubectl rollout status deployment/spring-api -n development
          kubectl rollout status deployment/frontend -n development

      - name: Run smoke tests
        run: |
          curl -f https://dev.car-service.com/health || exit 1

      - name: Notify Slack
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Deployment to Development: ${{ job.status }}'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}

  # ==================== DEPLOY TO STAGING ====================
  deploy-staging:
    needs: [build-images]
    if: startsWith(github.ref, 'refs/heads/release/')
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging.car-service.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Extract version
        id: version
        run: |
          VERSION=$(echo ${GITHUB_REF#refs/heads/release/})
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy to Kubernetes
        run: |
          # Update deployment with version tags
          kubectl set image deployment/nestjs-api \
            nestjs-api=${{ env.NESTJS_IMAGE }}:${{ steps.version.outputs.version }} \
            -n staging
          
          kubectl set image deployment/spring-api \
            spring-api=${{ env.SPRING_IMAGE }}:${{ steps.version.outputs.version }} \
            -n staging
          
          kubectl set image deployment/frontend \
            frontend=${{ env.FRONTEND_IMAGE }}:${{ steps.version.outputs.version }} \
            -n staging

      - name: Run database migrations
        run: |
          kubectl run migration-${{ github.sha }} \
            --image=${{ env.NESTJS_IMAGE }}:${{ steps.version.outputs.version }} \
            --restart=Never \
            --command -- npm run migration:run \
            -n staging

      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/nestjs-api -n staging
          kubectl rollout status deployment/spring-api -n staging
          kubectl rollout status deployment/frontend -n staging

      - name: Run integration tests
        run: |
          npm run test:integration:staging

      - name: Performance test
        run: |
          docker run --rm -i grafana/k6 run - < ./tests/load-test.js

  # ==================== DEPLOY TO PRODUCTION ====================
  deploy-production:
    needs: [build-images]
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://car-service.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_PROD }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Create backup
        run: |
          # Backup current deployment
          kubectl get deployment -n production -o yaml > backup-deployment.yaml
          
          # Backup database
          ./scripts/backup-database.sh

      - name: Deploy with blue-green strategy
        run: |
          # Deploy to green environment
          kubectl apply -f infrastructure/kubernetes/green/ -n production
          
          # Wait for green to be healthy
          kubectl wait --for=condition=available --timeout=300s \
            deployment/nestjs-api-green -n production

      - name: Run smoke tests on green
        run: |
          curl -f https://green.car-service.com/health || exit 1

      - name: Switch traffic to green
        run: |
          kubectl patch service nestjs-api \
            -p '{"spec":{"selector":{"version":"green"}}}' \
            -n production

      - name: Monitor for 5 minutes
        run: |
          sleep 300
          # Check error rates, response times
          ./scripts/check-metrics.sh

      - name: Cleanup old blue deployment
        run: |
          kubectl delete deployment -l version=blue -n production

      - name: Create Git tag
        run: |
          git tag -a v${{ github.run_number }} -m "Production release ${{ github.run_number }}"
          git push origin v${{ github.run_number }}

      - name: Notify team
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            🚀 Production Deployment Successful
            Version: v${{ github.run_number }}
            Commit: ${{ github.sha }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}

  # ==================== ROLLBACK (Manual Trigger) ====================
  rollback:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    environment:
      name: production

    steps:
      - name: Rollback to previous version
        run: |
          kubectl rollout undo deployment/nestjs-api -n production
          kubectl rollout undo deployment/spring-api -n production
          kubectl rollout undo deployment/frontend -n production

      - name: Restore database
        run: |
          ./scripts/restore-database.sh ${{ github.event.inputs.backup_id }}
```


## Environment-Specific Configurations

### Development Environment

**infrastructure/kubernetes/dev/deployment.yaml**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nestjs-api
  namespace: development
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nestjs-api
      env: dev
  template:
    metadata:
      labels:
        app: nestjs-api
        env: dev
    spec:
      containers:
      - name: nestjs-api
        image: your-org/car-service-nestjs:develop-latest
        env:
        - name: NODE_ENV
          value: "development"
        - name: DB_HOST
          value: "postgres-dev.default.svc.cluster.local"
        - name: REDIS_HOST
          value: "redis-dev.default.svc.cluster.local"
        - name: LOG_LEVEL
          value: "debug"
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 10
          periodSeconds: 5
```


### Production Environment (Blue-Green)

**infrastructure/kubernetes/production/deployment-green.yaml**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nestjs-api-green
  namespace: production
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: nestjs-api
      version: green
  template:
    metadata:
      labels:
        app: nestjs-api
        version: green
    spec:
      containers:
      - name: nestjs-api
        image: your-org/car-service-nestjs:latest
        env:
        - name: NODE_ENV
          value: "production"
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: host
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 60
          periodSeconds: 30
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
          failureThreshold: 3
```


## Database Migration Pipeline

**.github/workflows/database-migration.yml**

```yaml
name: Database Migration

on:
  push:
    branches:
      - develop
      - main
    paths:
      - 'database/migrations/**'

jobs:
  migrate-dev:
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    environment: development

    steps:
      - uses: actions/checkout@v4

      - name: Run migrations
        run: |
          docker run --rm \
            -e DATABASE_URL=${{ secrets.DEV_DATABASE_URL }} \
            -v $(pwd)/database/migrations:/migrations \
            migrate/migrate \
            -path=/migrations \
            -database ${{ secrets.DEV_DATABASE_URL }} \
            up

  migrate-staging:
    if: startsWith(github.ref, 'refs/heads/release/')
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - uses: actions/checkout@v4

      - name: Backup database
        run: |
          ./scripts/backup-database.sh staging

      - name: Run migrations
        run: |
          docker run --rm \
            -e DATABASE_URL=${{ secrets.STAGING_DATABASE_URL }} \
            -v $(pwd)/database/migrations:/migrations \
            migrate/migrate \
            -path=/migrations \
            -database ${{ secrets.STAGING_DATABASE_URL }} \
            up

      - name: Verify migration
        run: |
          ./scripts/verify-migration.sh staging

  migrate-production:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production

    steps:
      - uses: actions/checkout@v4

      - name: Create backup
        run: |
          ./scripts/backup-database.sh production

      - name: Dry-run migration
        run: |
          ./scripts/dry-run-migration.sh production

      - name: Wait for approval
        uses: trstringer/manual-approval@v1
        with:
          approvers: senior-dev-team
          minimum-approvals: 2

      - name: Run migrations
        run: |
          docker run --rm \
            -e DATABASE_URL=${{ secrets.PROD_DATABASE_URL }} \
            -v $(pwd)/database/migrations:/migrations \
            migrate/migrate \
            -path=/migrations \
            -database ${{ secrets.PROD_DATABASE_URL }} \
            up

      - name: Verify migration
        run: |
          ./scripts/verify-migration.sh production
```


## Monitoring and Alerts

**.github/workflows/monitoring.yml**

```yaml
name: Post-Deployment Monitoring

on:
  workflow_run:
    workflows: ["Car Service CI/CD Pipeline"]
    types:
      - completed

jobs:
  monitor:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}

    steps:
      - name: Check application health
        run: |
          for i in {1..10}; do
            if curl -f https://car-service.com/health; then
              echo "Health check passed"
              break
            fi
            echo "Retry $i/10"
            sleep 30
          done

      - name: Check error rates
        run: |
          # Query Prometheus/Grafana for error rates
          ERROR_RATE=$(curl -s "http://prometheus:9090/api/v1/query?query=rate(http_requests_total{status=~'5..'}[5m])")
          
          if [ "$ERROR_RATE" -gt "0.01" ]; then
            echo "High error rate detected: $ERROR_RATE"
            exit 1
          fi

      - name: Check response times
        run: |
          # Check average response time
          AVG_RESPONSE=$(curl -s "http://prometheus:9090/api/v1/query?query=http_request_duration_seconds")
          
          if [ "$AVG_RESPONSE" -gt "1.0" ]; then
            echo "High response time: $AVG_RESPONSE seconds"
            # Send alert but don't fail
          fi

      - name: Alert on failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: '🚨 Post-deployment monitoring failed!'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```


## CI/CD Workflow Summary

```
┌─────────────────────────────────────────────────────────────┐
│                    GIT PUSH EVENT                            │
└─────────────────┬───────────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────────┐
│  PHASE 1: CONTINUOUS INTEGRATION (CI)                        │
├─────────────────────────────────────────────────────────────┤
│  1. Detect Changes (paths-filter)                           │
│  2. Lint Code (ESLint, Prettier, Checkstyle)               │
│  3. Unit Tests (Jest, JUnit)                                │
│  4. Integration Tests (E2E, API Tests)                      │
│  5. Code Coverage (>80%)                                     │
│  6. Security Scan (Trivy, SonarQube)                        │
│  7. Build Validation                                         │
└─────────────────┬───────────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────────┐
│  PHASE 2: BUILD & PACKAGE                                    │
├─────────────────────────────────────────────────────────────┤
│  1. Build Docker Images                                      │
│  2. Tag with version (branch-sha, semver)                   │
│  3. Push to Docker Registry                                  │
│  4. Generate SBOM (Software Bill of Materials)              │
└─────────────────┬───────────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────────┐
│  PHASE 3: CONTINUOUS DEPLOYMENT (CD)                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────┐  ┌──────────┐  ┌──────────────┐              │
│  │ Develop  │  │ Release  │  │    Main      │              │
│  │ Branch   │  │ Branch   │  │   Branch     │              │
│  └────┬─────┘  └────┬─────┘  └──────┬───────┘              │
│       │             │               │                       │
│       ▼             ▼               ▼                       │
│  ┌────────┐   ┌─────────┐   ┌──────────────┐              │
│  │  DEV   │   │ STAGING │   │ PRODUCTION   │              │
│  │  Auto  │   │  Auto   │   │ + Approval   │              │
│  └────────┘   └─────────┘   └──────────────┘              │
└─────────────────────────────────────────────────────────────┘
```


## Best Practices Implementation

### 1. Fast Feedback Loop

- Unit tests run first (fastest)
- Integration tests run after
- Build only if tests pass
- Parallel execution where possible

### 2. Security First

- Scan dependencies for vulnerabilities
- Container image scanning
- Secret management with GitHub Secrets
- SBOM generation


### 3. Progressive Deployment

- Development: Automatic
- Staging: Automatic with tests
- Production: Manual approval + Blue-Green

### 4. Rollback Strategy

- Keep previous version running (Blue-Green)
- Database backups before migrations
- One-click rollback capability
- Automated health checks


### 5. Observability

- Health check endpoints
- Performance monitoring
- Error rate tracking
- Slack/Email notifications


ระบบ CI/CD นี้รองรับ Git Flow อย่างสมบูรณ์ โดยแต่ละ branch มี pipeline ที่เหมาะสม มีการตรวจสอบคุณภาพ ความปลอดภัย และการ deploy แบบอัตโนมัติที่ปลอดภัย 


<hr><hr><hr>
## การจัดการ Hotfix และ Rollback เมื่อ Deployment ล้มเหลว

การจัดการ hotfix และ rollback ที่มีประสิทธิภาพเป็นสิ่งสำคัญสำหรับระบบ production  ต่อไปนี้คือกลยุทธ์และขั้นตอนที่ครบถ้วน 
## Hotfix Strategy

### 1. Hotfix Workflow

```
Production Issue Detected
         ↓
    Assess Severity
         ↓
    ┌────────────────┐
    │ Critical Bug?  │
    └────┬──────┬────┘
         │      │
    Yes  │      │  No → Create normal bugfix
         ↓
Create Hotfix Branch from main
         ↓
Fix → Test → Review → Merge
         ↓
Deploy to Production (Fast-track)
         ↓
Merge back to develop
         ↓
Post-mortem Analysis
```


### 2. Hotfix Branch Strategy

**สร้าง Hotfix Branch**

```bash
# 1. Create hotfix branch from main (production)
git checkout main
git pull origin main
git checkout -b hotfix/v1.0.1-fix-payment-timeout

# 2. Apply the fix
# Edit files...
git add .
git commit -m "fix(payment): increase timeout from 10s to 30s

- Update payment gateway timeout configuration
- Add retry logic for timeout scenarios
- Add monitoring alert for payment failures

Fixes: #TICKET-301
Severity: Critical
Impact: Payment failures affecting 15% of transactions"

# 3. Bump patch version
npm version patch  # 1.0.0 → 1.0.1

# 4. Push hotfix branch
git push origin hotfix/v1.0.1-fix-payment-timeout
```


### 3. Fast-Track Hotfix Pipeline

**.github/workflows/hotfix.yml**

```yaml
name: Hotfix Deployment

on:
  push:
    branches:
      - 'hotfix/**'

env:
  SEVERITY: critical

jobs:
  # ==================== VALIDATE HOTFIX ====================
  validate-hotfix:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Extract hotfix info
        id: hotfix
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          VERSION=$(echo $BRANCH_NAME | sed 's/hotfix\///')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH_NAME" >> $GITHUB_OUTPUT

      - name: Verify hotfix branch from main
        run: |
          git fetch origin main
          MERGE_BASE=$(git merge-base HEAD origin/main)
          MAIN_HEAD=$(git rev-parse origin/main)
          
          if [ "$MERGE_BASE" != "$MAIN_HEAD" ]; then
            echo "❌ Hotfix must be created from main branch"
            exit 1
          fi

      - name: Check for breaking changes
        run: |
          # Ensure no schema changes in hotfix
          if git diff origin/main --name-only | grep -E "migration|schema"; then
            echo "⚠️  Warning: Database changes detected in hotfix"
            echo "This requires manual approval"
          fi

  # ==================== EXPEDITED TESTING ====================
  expedited-tests:
    needs: validate-hotfix
    runs-on: ubuntu-latest
    timeout-minutes: 15  # Fast timeout for hotfixes

    steps:
      - uses: actions/checkout@v4

      - name: Setup environment
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci
        working-directory: backend/nestjs-api

      - name: Run critical tests only
        run: |
          # Run only tests related to the fix
          npm test -- --testPathPattern="payment" --coverage
        working-directory: backend/nestjs-api

      - name: Security scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          severity: 'CRITICAL,HIGH'

  # ==================== BUILD HOTFIX ====================
  build-hotfix:
    needs: expedited-tests
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to registry
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract version
        id: version
        run: |
          VERSION=$(echo ${GITHUB_REF#refs/heads/hotfix/})
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Build and push hotfix image
        uses: docker/build-push-action@v5
        with:
          context: backend/nestjs-api
          push: true
          tags: |
            your-org/car-service-nestjs:${{ steps.version.outputs.version }}
            your-org/car-service-nestjs:hotfix-latest
          labels: |
            hotfix=true
            severity=critical
            version=${{ steps.version.outputs.version }}

  # ==================== DEPLOY TO STAGING FOR VALIDATION ====================
  deploy-staging-validation:
    needs: build-hotfix
    runs-on: ubuntu-latest
    environment:
      name: staging-hotfix
      url: https://hotfix-staging.car-service.com

    steps:
      - uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Deploy to isolated staging
        run: |
          # Deploy to isolated namespace for hotfix validation
          kubectl create namespace hotfix-validation --dry-run=client -o yaml | kubectl apply -f -
          
          kubectl set image deployment/nestjs-api \
            nestjs-api=your-org/car-service-nestjs:${{ needs.validate-hotfix.outputs.version }} \
            -n hotfix-validation

      - name: Wait for deployment
        run: |
          kubectl rollout status deployment/nestjs-api -n hotfix-validation --timeout=5m

      - name: Run smoke tests
        run: |
          # Test the specific fix
          npm run test:hotfix:payment
          
      - name: Load test the fix
        run: |
          # Simulate production load
          k6 run --vus 100 --duration 2m tests/payment-load-test.js

  # ==================== PRODUCTION DEPLOYMENT ====================
  deploy-production:
    needs: deploy-staging-validation
    runs-on: ubuntu-latest
    environment:
      name: production-hotfix
      url: https://car-service.com

    steps:
      - uses: actions/checkout@v4

      - name: Notify team - Deployment starting
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "🚨 HOTFIX DEPLOYMENT STARTING",
              attachments: [{
                color: 'warning',
                text: `Version: ${{ needs.validate-hotfix.outputs.version }}\nSeverity: Critical\nDeploying by: ${{ github.actor }}`
              }]
            }
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}

      - name: Create pre-deployment backup
        run: |
          # Backup current state
          kubectl get all -n production -o yaml > backup-$(date +%s).yaml
          
          # Backup database
          ./scripts/backup-database.sh production hotfix-backup

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_PROD }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Deploy hotfix with canary strategy
        run: |
          # Deploy to 10% of traffic first
          kubectl set image deployment/nestjs-api-canary \
            nestjs-api=your-org/car-service-nestjs:${{ needs.validate-hotfix.outputs.version }} \
            -n production
          
          # Wait for canary to be healthy
          kubectl rollout status deployment/nestjs-api-canary -n production

      - name: Monitor canary for 5 minutes
        run: |
          ./scripts/monitor-canary.sh 300
          
          # Check metrics
          ERROR_RATE=$(./scripts/get-error-rate.sh)
          
          if (( $(echo "$ERROR_RATE > 0.01" | bc -l) )); then
            echo "❌ High error rate detected: $ERROR_RATE"
            echo "ROLLBACK_NEEDED=true" >> $GITHUB_ENV
            exit 1
          fi

      - name: Roll out to all instances
        if: env.ROLLBACK_NEEDED != 'true'
        run: |
          kubectl set image deployment/nestjs-api \
            nestjs-api=your-org/car-service-nestjs:${{ needs.validate-hotfix.outputs.version }} \
            -n production
          
          kubectl rollout status deployment/nestjs-api -n production

      - name: Verify production deployment
        run: |
          # Run production smoke tests
          ./scripts/production-smoke-tests.sh
          
          # Verify the specific fix
          curl -f https://car-service.com/api/v1/health
          ./scripts/verify-payment-fix.sh

      - name: Create Git tag
        run: |
          git tag -a ${{ needs.validate-hotfix.outputs.version }} \
            -m "Hotfix: ${{ needs.validate-hotfix.outputs.version }}"
          git push origin ${{ needs.validate-hotfix.outputs.version }}

      - name: Merge hotfix to main
        run: |
          git checkout main
          git merge --no-ff hotfix/${{ needs.validate-hotfix.outputs.version }}
          git push origin main

      - name: Merge hotfix to develop
        run: |
          git checkout develop
          git merge --no-ff hotfix/${{ needs.validate-hotfix.outputs.version }}
          git push origin develop

      - name: Delete hotfix branch
        run: |
          git push origin --delete hotfix/${{ needs.validate-hotfix.outputs.version }}

      - name: Notify team - Success
        if: success()
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            ✅ HOTFIX DEPLOYED SUCCESSFULLY
            Version: ${{ needs.validate-hotfix.outputs.version }}
            Time: $(date)
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}

  # ==================== ROLLBACK ON FAILURE ====================
  rollback-on-failure:
    needs: deploy-production
    if: failure()
    runs-on: ubuntu-latest

    steps:
      - name: Emergency rollback
        run: |
          kubectl rollout undo deployment/nestjs-api -n production
          kubectl rollout undo deployment/nestjs-api-canary -n production

      - name: Restore database
        run: |
          ./scripts/restore-database.sh production hotfix-backup

      - name: Alert team
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: |
            🚨 HOTFIX DEPLOYMENT FAILED - ROLLED BACK
            Version: ${{ needs.validate-hotfix.outputs.version }}
            System restored to previous state
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```


## Rollback Strategies

### 1. Kubernetes Automatic Rollback

**deployment.yaml with automatic rollback**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nestjs-api
  namespace: production
spec:
  replicas: 3
  progressDeadlineSeconds: 600  # 10 minutes timeout
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0  # Zero downtime
  minReadySeconds: 30  # Wait 30s before considering pod ready
  
  template:
    metadata:
      labels:
        app: nestjs-api
    spec:
      containers:
      - name: nestjs-api
        image: your-org/car-service-nestjs:latest
        
        # Health checks for automatic rollback
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 60
          periodSeconds: 10
          failureThreshold: 3  # Fail after 3 attempts
          successThreshold: 1
          timeoutSeconds: 5
        
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 5
          failureThreshold: 3
          successThreshold: 1
          timeoutSeconds: 3
        
        # Startup probe for slow starting apps
        startupProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 0
          periodSeconds: 10
          failureThreshold: 30  # 5 minutes total
```


### 2. Manual Rollback Commands

**Rollback Scripts**

**scripts/rollback-production.sh**

```bash
#!/bin/bash

set -e

NAMESPACE="production"
DEPLOYMENT_NAME="nestjs-api"

echo "🔄 Starting rollback process..."

# Get current revision
CURRENT_REVISION=$(kubectl rollout history deployment/$DEPLOYMENT_NAME -n $NAMESPACE | tail -1 | awk '{print $1}')
echo "Current revision: $CURRENT_REVISION"

# Get previous revision
PREVIOUS_REVISION=$((CURRENT_REVISION - 1))
echo "Rolling back to revision: $PREVIOUS_REVISION"

# Confirm rollback
read -p "Are you sure you want to rollback? (yes/no): " CONFIRM
if [ "$CONFIRM" != "yes" ]; then
    echo "Rollback cancelled"
    exit 0
fi

# Create backup of current state
echo "📦 Creating backup..."
kubectl get deployment $DEPLOYMENT_NAME -n $NAMESPACE -o yaml > "backup-before-rollback-$(date +%s).yaml"

# Perform rollback
echo "⏪ Rolling back..."
kubectl rollout undo deployment/$DEPLOYMENT_NAME -n $NAMESPACE

# Wait for rollback to complete
echo "⏳ Waiting for rollback to complete..."
kubectl rollout status deployment/$DEPLOYMENT_NAME -n $NAMESPACE --timeout=5m

# Verify rollback
echo "✅ Verifying rollback..."
kubectl get pods -n $NAMESPACE -l app=$DEPLOYMENT_NAME

# Check health
echo "🏥 Checking application health..."
sleep 10
HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://car-service.com/health)

if [ "$HEALTH_STATUS" == "200" ]; then
    echo "✅ Rollback successful - Application is healthy"
else
    echo "❌ Rollback completed but health check failed"
    exit 1
fi

# Notify team
curl -X POST $SLACK_WEBHOOK \
  -H 'Content-Type: application/json' \
  -d "{
    \"text\": \"✅ Production rollback completed successfully\",
    \"attachments\": [{
      \"color\": \"good\",
      \"fields\": [
        {\"title\": \"Deployment\", \"value\": \"$DEPLOYMENT_NAME\", \"short\": true},
        {\"title\": \"Revision\", \"value\": \"$PREVIOUS_REVISION\", \"short\": true},
        {\"title\": \"Executed by\", \"value\": \"$USER\", \"short\": true}
      ]
    }]
  }"

echo "🎉 Rollback complete!"
```


### 3. Blue-Green Rollback

**Instant rollback by switching service**

```bash
#!/bin/bash

# Current: Green is live, Blue is previous version

echo "🔄 Performing instant rollback via traffic switch..."

# Switch service to point to blue (old) deployment
kubectl patch service nestjs-api -n production \
  --type='json' \
  -p='[{"op": "replace", "path": "/spec/selector/version", "value": "blue"}]'

echo "✅ Traffic switched to blue environment (previous version)"

# Verify
kubectl get service nestjs-api -n production -o jsonpath='{.spec.selector}'

# Monitor for 2 minutes
echo "📊 Monitoring application..."
sleep 120

# Check error rates
ERROR_RATE=$(./scripts/get-error-rate.sh)
echo "Error rate: $ERROR_RATE"

if (( $(echo "$ERROR_RATE < 0.01" | bc -l) )); then
    echo "✅ Rollback successful - System stable"
    
    # Scale down green (failed) deployment
    kubectl scale deployment/nestjs-api-green --replicas=0 -n production
else
    echo "⚠️  Warning: Error rate still elevated"
fi
```


### 4. Database Rollback Strategy

**scripts/database-rollback.sh**

```bash
#!/bin/bash

set -e

ENVIRONMENT=$1
BACKUP_ID=$2

if [ -z "$ENVIRONMENT" ] || [ -z "$BACKUP_ID" ]; then
    echo "Usage: ./database-rollback.sh <environment> <backup-id>"
    exit 1
fi

echo "⚠️  DATABASE ROLLBACK - This is a critical operation!"
echo "Environment: $ENVIRONMENT"
echo "Backup ID: $BACKUP_ID"

# Confirm
read -p "Type 'ROLLBACK' to confirm: " CONFIRM
if [ "$CONFIRM" != "ROLLBACK" ]; then
    echo "Cancelled"
    exit 0
fi

# Get database credentials
DB_HOST=$(kubectl get secret db-credentials -n $ENVIRONMENT -o jsonpath='{.data.host}' | base64 -d)
DB_NAME=$(kubectl get secret db-credentials -n $ENVIRONMENT -o jsonpath='{.data.database}' | base64 -d)

echo "📦 Creating pre-rollback backup..."
pg_dump -h $DB_HOST -U postgres $DB_NAME > "pre-rollback-$(date +%s).sql"

echo "🔄 Restoring from backup..."
# Download backup from S3
aws s3 cp s3://backups/$ENVIRONMENT/$BACKUP_ID.sql ./restore.sql

# Stop application traffic
kubectl scale deployment/nestjs-api --replicas=0 -n $ENVIRONMENT

# Restore database
psql -h $DB_HOST -U postgres $DB_NAME < restore.sql

# Restart application
kubectl scale deployment/nestjs-api --replicas=3 -n $ENVIRONMENT

# Wait for pods
kubectl rollout status deployment/nestjs-api -n $ENVIRONMENT

echo "✅ Database rollback complete"

# Verify data
echo "🔍 Verifying data integrity..."
./scripts/verify-database.sh $ENVIRONMENT

# Notify
curl -X POST $SLACK_WEBHOOK \
  -H 'Content-Type: application/json' \
  -d "{\"text\": \"⚠️ Database rolled back in $ENVIRONMENT to backup $BACKUP_ID\"}"
```


## Rollback Decision Matrix

| Severity | Symptoms | Rollback Strategy | Approval Required | Estimated Time |
| :-- | :-- | :-- | :-- | :-- |
| **Critical** | Service down, >50% errors | Immediate blue-green switch | Post-facto | < 1 min |
| **High** | >10% errors, performance degraded | Kubernetes rollback | DevOps lead | 5-10 min |
| **Medium** | <10% errors, specific feature broken | Redeploy previous version | Team lead | 15-30 min |
| **Low** | Minor issues, workaround available | Schedule proper fix | Product owner | Next deploy |

## Monitoring and Alerting

**Automated Monitoring Script**

**scripts/monitor-deployment.sh**

```bash
#!/bin/bash

DEPLOYMENT=$1
NAMESPACE=$2
DURATION=${3:-300}  # Default 5 minutes

echo "📊 Monitoring deployment: $DEPLOYMENT in $NAMESPACE for ${DURATION}s"

START_TIME=$(date +%s)
FAILED_CHECKS=0
MAX_FAILURES=3

while [ $(($(date +%s) - START_TIME)) -lt $DURATION ]; do
    # Check pod status
    READY_PODS=$(kubectl get deployment $DEPLOYMENT -n $NAMESPACE -o jsonpath='{.status.readyReplicas}')
    DESIRED_PODS=$(kubectl get deployment $DEPLOYMENT -n $NAMESPACE -o jsonpath='{.spec.replicas}')
    
    # Check error rate from Prometheus
    ERROR_RATE=$(curl -s "http://prometheus:9090/api/v1/query?query=rate(http_requests_total{status=~'5..'}[1m])" | jq -r '.data.result[^0].value[^1]')
    
    # Check response time
    AVG_RESPONSE=$(curl -s "http://prometheus:9090/api/v1/query?query=histogram_quantile(0.95,rate(http_request_duration_seconds_bucket[1m]))" | jq -r '.data.result[^0].value[^1]')
    
    echo "[$(date +%T)] Pods: $READY_PODS/$DESIRED_PODS | Error Rate: $ERROR_RATE | P95 Latency: ${AVG_RESPONSE}s"
    
    # Check conditions
    if [ "$READY_PODS" != "$DESIRED_PODS" ]; then
        echo "⚠️  Warning: Not all pods are ready"
        ((FAILED_CHECKS++))
    elif (( $(echo "$ERROR_RATE > 0.05" | bc -l) )); then
        echo "⚠️  Warning: High error rate"
        ((FAILED_CHECKS++))
    elif (( $(echo "$AVG_RESPONSE > 2.0" | bc -l) )); then
        echo "⚠️  Warning: High latency"
        ((FAILED_CHECKS++))
    else
        echo "✅ All metrics healthy"
        FAILED_CHECKS=0
    fi
    
    # Trigger rollback if too many failures
    if [ $FAILED_CHECKS -ge $MAX_FAILURES ]; then
        echo "🚨 CRITICAL: Too many failed checks - Triggering automatic rollback"
        ./scripts/rollback-production.sh
        exit 1
    fi
    
    sleep 30
done

echo "✅ Monitoring complete - Deployment appears stable"
```


## Post-Incident Checklist

```markdown
## Post-Hotfix/Rollback Checklist

### Immediate Actions (Within 1 hour)
- [ ] Verify system stability
- [ ] Check all metrics returned to normal
- [ ] Confirm no data loss
- [ ] Notify all stakeholders
- [ ] Document the incident

### Short-term Actions (Within 24 hours)
- [ ] Root cause analysis
- [ ] Update runbooks
- [ ] Review monitoring/alerting
- [ ] Plan permanent fix
- [ ] Schedule post-mortem meeting

### Long-term Actions (Within 1 week)
- [ ] Implement permanent fix
- [ ] Add tests to prevent regression
- [ ] Update deployment process
- [ ] Training session if needed
- [ ] Update disaster recovery plan

### Post-Mortem Questions
1. What triggered the issue?
2. How was it detected?
3. What was the impact?
4. How long to resolve?
5. What worked well?
6. What could be improved?
7. Action items to prevent recurrence
```


## Best Practices Summary

### Hotfix Best Practices ✅

- **Create from production** (main branch), not develop
- **Keep changes minimal** - fix only the critical issue
- **Fast-track testing** - focus on affected areas only
- **Deploy to staging first** - even for hotfixes
- **Merge back to develop** - keep branches in sync
- **Document thoroughly** - why, what, how


### Rollback Best Practices ✅

- **Automate monitoring** - detect issues early
- **Multiple rollback options** - blue-green, Kubernetes, manual
- **Practice regularly** - test rollback procedures
- **Keep previous versions** - don't delete immediately
- **Database backups** - before every deployment
- **Clear communication** - notify team immediately


### Things to Avoid ❌

- ❌ Deploying hotfix without testing
- ❌ Making multiple changes in one hotfix
- ❌ Skipping code review for hotfixes
- ❌ Forgetting to merge back to develop
- ❌ No monitoring after deployment
- ❌ Deleting old deployments too quickly

การมีระบบ hotfix และ rollback ที่ดีช่วยให้ทีมสามารถจัดการปัญหาใน production ได้อย่างรวดเร็วและปลอดภัย ลดผลกระทบต่อผู้ใช้งานให้เหลือน้อยที่สุด

<hr> <hr>

# Monitoring 

## การใช้ ELK Stack และ Grafana สำหรับ Logging และ Monitoring

การผสมผสาน ELK Stack (Elasticsearch, Logstash, Kibana) สำหรับ centralized logging และ Grafana + Prometheus สำหรับ monitoring จะช่วยให้มี observability ที่สมบูรณ์สำหรับระบบศูนย์บริการรถยนต์ 

## สถาปัตยกรรม Observability

```
┌─────────────────────────────────────────────────────────────┐
│                  APPLICATION LAYER                           │
│  NestJS API  │  Spring Boot API  │  React Frontend          │
└──────┬───────────────┬──────────────────┬───────────────────┘
       │               │                  │
       │ Logs          │ Logs             │ Logs
       ▼               ▼                  ▼
┌──────────────────────────────────────────────────────────────┐
│              FILEBEAT (Log Collector)                        │
│              Running as DaemonSet                            │
└──────┬───────────────────────────────────────────────────────┘
       │
       │ Forward Logs
       ▼
┌──────────────────────────────────────────────────────────────┐
│              LOGSTASH (Log Processing)                        │
│              Parse, Filter, Transform                         │
└──────┬───────────────────────────────────────────────────────┘
       │
       │ Store Logs
       ▼
┌──────────────────────────────────────────────────────────────┐
│              ELASTICSEARCH (Log Storage)                      │
│              Index & Search Engine                            │
└──────┬────────────────────────┬──────────────────────────────┘
       │                        │
       │ Query                  │ Query
       ▼                        ▼
┌──────────────┐         ┌─────────────────┐
│    KIBANA    │         │    GRAFANA      │
│ Log Analysis │         │ Unified Dashboards│
└──────────────┘         └────────┬─────────┘
                                  │
                         Also connects to:
                                  │
                         ┌────────▼─────────┐
                         │   PROMETHEUS     │
                         │  (Metrics Store) │
                         └──────────────────┘
```


## 1. ELK Stack Deployment

### Namespace และ Storage

**infrastructure/kubernetes/monitoring/namespace.yaml**

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: logging
  labels:
    name: logging
---
apiVersion: v1
kind: Namespace
metadata:
  name: monitoring
  labels:
    name: monitoring
```


### Elasticsearch Deployment

**infrastructure/kubernetes/elk/elasticsearch.yaml**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: elasticsearch
  namespace: logging
  labels:
    app: elasticsearch
spec:
  selector:
    app: elasticsearch
  clusterIP: None
  ports:
  - port: 9200
    name: rest
  - port: 9300
    name: inter-node
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: elasticsearch
  namespace: logging
spec:
  serviceName: elasticsearch
  replicas: 3
  selector:
    matchLabels:
      app: elasticsearch
  template:
    metadata:
      labels:
        app: elasticsearch
    spec:
      containers:
      - name: elasticsearch
        image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0
        resources:
          limits:
            memory: 4Gi
            cpu: 2000m
          requests:
            memory: 2Gi
            cpu: 1000m
        ports:
        - containerPort: 9200
          name: rest
          protocol: TCP
        - containerPort: 9300
          name: inter-node
          protocol: TCP
        volumeMounts:
        - name: data
          mountPath: /usr/share/elasticsearch/data
        env:
        - name: cluster.name
          value: k8s-logs
        - name: node.name
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: discovery.seed_hosts
          value: "elasticsearch-0.elasticsearch,elasticsearch-1.elasticsearch,elasticsearch-2.elasticsearch"
        - name: cluster.initial_master_nodes
          value: "elasticsearch-0,elasticsearch-1,elasticsearch-2"
        - name: ES_JAVA_OPTS
          value: "-Xms2g -Xmx2g"
        - name: xpack.security.enabled
          value: "false"
      initContainers:
      - name: fix-permissions
        image: busybox
        command: ["sh", "-c", "chown -R 1000:1000 /usr/share/elasticsearch/data"]
        securityContext:
          privileged: true
        volumeMounts:
        - name: data
          mountPath: /usr/share/elasticsearch/data
      - name: increase-vm-max-map
        image: busybox
        command: ["sysctl", "-w", "vm.max_map_count=262144"]
        securityContext:
          privileged: true
  volumeClaimTemplates:
  - metadata:
      name: data
      labels:
        app: elasticsearch
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: gp2  # AWS EBS, adjust for your provider
      resources:
        requests:
          storage: 100Gi
```


### Logstash Deployment

**infrastructure/kubernetes/elk/logstash.yaml**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: logstash-config
  namespace: logging
data:
  logstash.yml: |
    http.host: "0.0.0.0"
    xpack.monitoring.elasticsearch.hosts: [ "http://elasticsearch:9200" ]
  
  logstash.conf: |
    input {
      beats {
        port => 5044
      }
    }
    
    filter {
      # Parse JSON logs
      if [message] =~ /^\{.*\}$/ {
        json {
          source => "message"
        }
      }
      
      # Parse NestJS logs
      if [kubernetes][container][name] == "nestjs-api" {
        grok {
          match => { "message" => "\[%{DATA:log_level}\] %{NUMBER:pid} - %{TIMESTAMP_ISO8601:timestamp} %{GREEDYDATA:log_message}" }
        }
      }
      
      # Parse Spring Boot logs
      if [kubernetes][container][name] == "spring-api" {
        grok {
          match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} %{NUMBER:pid} --- \[%{DATA:thread}\] %{DATA:class} : %{GREEDYDATA:log_message}" }
        }
      }
      
      # Add custom fields
      mutate {
        add_field => {
          "environment" => "${ENVIRONMENT:production}"
          "application" => "car-service"
        }
      }
      
      # Parse timestamps
      date {
        match => [ "timestamp", "ISO8601" ]
        target => "@timestamp"
      }
      
      # Remove unnecessary fields
      mutate {
        remove_field => [ "host", "agent", "ecs", "input" ]
      }
    }
    
    output {
      elasticsearch {
        hosts => ["http://elasticsearch:9200"]
        index => "car-service-%{[kubernetes][namespace]}-%{+YYYY.MM.dd}"
        manage_template => true
        template_name => "car-service"
        template_overwrite => true
      }
      
      # Debug output (remove in production)
      # stdout { codec => rubydebug }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: logstash
  namespace: logging
spec:
  replicas: 2
  selector:
    matchLabels:
      app: logstash
  template:
    metadata:
      labels:
        app: logstash
    spec:
      containers:
      - name: logstash
        image: docker.elastic.co/logstash/logstash:8.11.0
        ports:
        - containerPort: 5044
          name: beats
        volumeMounts:
        - name: config
          mountPath: /usr/share/logstash/config/logstash.yml
          subPath: logstash.yml
        - name: pipeline
          mountPath: /usr/share/logstash/pipeline/logstash.conf
          subPath: logstash.conf
        env:
        - name: LS_JAVA_OPTS
          value: "-Xmx1g -Xms1g"
        - name: ENVIRONMENT
          value: "production"
        resources:
          limits:
            memory: 2Gi
            cpu: 1000m
          requests:
            memory: 1Gi
            cpu: 500m
      volumes:
      - name: config
        configMap:
          name: logstash-config
          items:
          - key: logstash.yml
            path: logstash.yml
      - name: pipeline
        configMap:
          name: logstash-config
          items:
          - key: logstash.conf
            path: logstash.conf
---
apiVersion: v1
kind: Service
metadata:
  name: logstash
  namespace: logging
spec:
  selector:
    app: logstash
  ports:
  - port: 5044
    targetPort: 5044
    name: beats
```


### Filebeat DaemonSet

**infrastructure/kubernetes/elk/filebeat.yaml**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: filebeat-config
  namespace: logging
data:
  filebeat.yml: |
    filebeat.inputs:
    - type: container
      paths:
        - /var/log/containers/*.log
      processors:
      - add_kubernetes_metadata:
          host: ${NODE_NAME}
          matchers:
          - logs_path:
              logs_path: "/var/log/containers/"
      - drop_event:
          when:
            or:
            - equals:
                kubernetes.namespace: "kube-system"
            - equals:
                kubernetes.namespace: "logging"
            - equals:
                kubernetes.namespace: "monitoring"
    
    output.logstash:
      hosts: ["logstash:5044"]
      loadbalance: true
    
    logging.level: info
    logging.to_files: false
    logging.to_syslog: false
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: filebeat
  namespace: logging
  labels:
    app: filebeat
spec:
  selector:
    matchLabels:
      app: filebeat
  template:
    metadata:
      labels:
        app: filebeat
    spec:
      serviceAccountName: filebeat
      terminationGracePeriodSeconds: 30
      hostNetwork: true
      dnsPolicy: ClusterFirstWithHostNet
      containers:
      - name: filebeat
        image: docker.elastic.co/beats/filebeat:8.11.0
        args: [
          "-c", "/etc/filebeat.yml",
          "-e",
        ]
        env:
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        securityContext:
          runAsUser: 0
        resources:
          limits:
            memory: 200Mi
            cpu: 100m
          requests:
            memory: 100Mi
            cpu: 50m
        volumeMounts:
        - name: config
          mountPath: /etc/filebeat.yml
          readOnly: true
          subPath: filebeat.yml
        - name: data
          mountPath: /usr/share/filebeat/data
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
        - name: varlog
          mountPath: /var/log
          readOnly: true
      volumes:
      - name: config
        configMap:
          defaultMode: 0640
          name: filebeat-config
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
      - name: varlog
        hostPath:
          path: /var/log
      - name: data
        hostPath:
          path: /var/lib/filebeat-data
          type: DirectoryOrCreate
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: filebeat
rules:
- apiGroups: [""]
  resources:
  - namespaces
  - pods
  - nodes
  verbs:
  - get
  - watch
  - list
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: filebeat
  namespace: logging
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: filebeat
subjects:
- kind: ServiceAccount
  name: filebeat
  namespace: logging
roleRef:
  kind: ClusterRole
  name: filebeat
  apiGroup: rbac.authorization.k8s.io
```


### Kibana Deployment

**infrastructure/kubernetes/elk/kibana.yaml**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: kibana
  namespace: logging
spec:
  replicas: 1
  selector:
    matchLabels:
      app: kibana
  template:
    metadata:
      labels:
        app: kibana
    spec:
      containers:
      - name: kibana
        image: docker.elastic.co/kibana/kibana:8.11.0
        resources:
          limits:
            memory: 2Gi
            cpu: 1000m
          requests:
            memory: 1Gi
            cpu: 500m
        env:
        - name: ELASTICSEARCH_HOSTS
          value: "http://elasticsearch:9200"
        - name: SERVER_NAME
          value: "kibana"
        - name: SERVER_BASEPATH
          value: "/kibana"
        ports:
        - containerPort: 5601
---
apiVersion: v1
kind: Service
metadata:
  name: kibana
  namespace: logging
spec:
  selector:
    app: kibana
  ports:
  - port: 5601
    targetPort: 5601
  type: LoadBalancer
```


## 2. Prometheus + Grafana Monitoring Stack

### Prometheus Deployment with Helm

**Deploy Prometheus using Prometheus Operator**

```bash
# Add Helm repository
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update

# Install Prometheus Stack (includes Grafana)
helm install prometheus prometheus-community/kube-prometheus-stack \
  --namespace monitoring \
  --create-namespace \
  --set prometheus.prometheusSpec.retention=30d \
  --set prometheus.prometheusSpec.storageSpec.volumeClaimTemplate.spec.resources.requests.storage=100Gi \
  --set grafana.adminPassword=admin123 \
  --set grafana.persistence.enabled=true \
  --set grafana.persistence.size=10Gi
```


### Custom ServiceMonitor for Applications

**infrastructure/kubernetes/monitoring/servicemonitor.yaml**

```yaml
apiVersion: v1
kind: Service
metadata:
  name: nestjs-api-metrics
  namespace: production
  labels:
    app: nestjs-api
spec:
  selector:
    app: nestjs-api
  ports:
  - name: metrics
    port: 9090
    targetPort: 9090
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: nestjs-api-monitor
  namespace: monitoring
  labels:
    release: prometheus
spec:
  selector:
    matchLabels:
      app: nestjs-api
  namespaceSelector:
    matchNames:
    - production
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: spring-api-monitor
  namespace: monitoring
  labels:
    release: prometheus
spec:
  selector:
    matchLabels:
      app: spring-api
  namespaceSelector:
    matchNames:
    - production
  endpoints:
  - port: metrics
    interval: 30s
    path: /actuator/prometheus
```


### Application Metrics Configuration

**NestJS with Prometheus**

**backend/nestjs-api/src/metrics/metrics.module.ts**

```typescript
import { Module } from '@nestjs/common';
import { PrometheusModule } from '@willsoto/nestjs-prometheus';
import { MetricsController } from './metrics.controller';

@Module({
  imports: [
    PrometheusModule.register({
      path: '/metrics',
      defaultMetrics: {
        enabled: true,
      },
    }),
  ],
  controllers: [MetricsController],
})
export class MetricsModule {}
```

**Custom Metrics**

```typescript
import { Injectable } from '@nestjs/common';
import { Counter, Histogram, makeCounterProvider, makeHistogramProvider } from '@willsoto/nestjs-prometheus';

@Injectable()
export class MetricsService {
  constructor(
    private readonly bookingCounter: Counter<string>,
    private readonly requestDuration: Histogram<string>,
  ) {}

  incrementBookings(status: string) {
    this.bookingCounter.inc({ status });
  }

  recordRequestDuration(method: string, path: string, duration: number) {
    this.requestDuration.observe({ method, path }, duration);
  }
}

export const bookingCounterProvider = makeCounterProvider({
  name: 'booking_total',
  help: 'Total number of bookings',
  labelNames: ['status'],
});

export const requestDurationProvider = makeHistogramProvider({
  name: 'http_request_duration_seconds',
  help: 'HTTP request duration in seconds',
  labelNames: ['method', 'path'],
  buckets: [0.1, 0.5, 1, 2, 5],
});
```

**Spring Boot with Micrometer**

**pom.xml**

```xml
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**application.yml**

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: car-service-spring
      environment: production
```


## 3. Grafana Dashboards

### Connect Elasticsearch to Grafana

**Add Elasticsearch Data Source in Grafana**

```json
{
  "name": "Elasticsearch-Logs",
  "type": "elasticsearch",
  "access": "proxy",
  "url": "http://elasticsearch.logging.svc.cluster.local:9200",
  "database": "car-service-*",
  "jsonData": {
    "timeField": "@timestamp",
    "esVersion": "8.0.0",
    "logMessageField": "message",
    "logLevelField": "log_level"
  }
}
```


### Application Overview Dashboard

**infrastructure/grafana-dashboards/car-service-overview.json**

```json
{
  "dashboard": {
    "title": "Car Service System Overview",
    "panels": [
      {
        "title": "Request Rate",
        "targets": [
          {
            "expr": "sum(rate(http_requests_total[5m])) by (service)",
            "legendFormat": "{{service}}"
          }
        ],
        "type": "graph"
      },
      {
        "title": "Error Rate",
        "targets": [
          {
            "expr": "sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m])) * 100",
            "legendFormat": "Error %"
          }
        ],
        "type": "graph"
      },
      {
        "title": "Response Time (P95)",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le, service))",
            "legendFormat": "{{service}} P95"
          }
        ],
        "type": "graph"
      },
      {
        "title": "Active Bookings",
        "targets": [
          {
            "expr": "booking_total{status=\"confirmed\"}",
            "legendFormat": "Active"
          }
        ],
        "type": "stat"
      },
      {
        "title": "Database Connections",
        "targets": [
          {
            "expr": "pg_stat_activity_count",
            "legendFormat": "{{datname}}"
          }
        ],
        "type": "graph"
      },
      {
        "title": "Redis Hit Rate",
        "targets": [
          {
            "expr": "redis_keyspace_hits_total / (redis_keyspace_hits_total + redis_keyspace_misses_total) * 100",
            "legendFormat": "Hit Rate %"
          }
        ],
        "type": "gauge"
      }
    ]
  }
}
```


### Logs Dashboard

**Query logs from Elasticsearch in Grafana**

```json
{
  "title": "Application Logs",
  "panels": [
    {
      "title": "Error Logs",
      "targets": [
        {
          "datasource": "Elasticsearch-Logs",
          "query": "log_level:ERROR",
          "timeField": "@timestamp"
        }
      ],
      "type": "logs"
    },
    {
      "title": "Booking Events",
      "targets": [
        {
          "datasource": "Elasticsearch-Logs",
          "query": "kubernetes.container.name:nestjs-api AND log_message:*booking*",
          "timeField": "@timestamp"
        }
      ],
      "type": "logs"
    }
  ]
}
```


## 4. Alerting Configuration

### Prometheus Alert Rules

**infrastructure/kubernetes/monitoring/prometheus-rules.yaml**

```yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: car-service-alerts
  namespace: monitoring
  labels:
    release: prometheus
spec:
  groups:
  - name: car-service
    interval: 30s
    rules:
    # High Error Rate
    - alert: HighErrorRate
      expr: |
        (
          sum(rate(http_requests_total{status=~"5.."}[5m]))
          /
          sum(rate(http_requests_total[5m]))
        ) > 0.05
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "High error rate detected"
        description: "Error rate is {{ $value | humanizePercentage }} (threshold: 5%)"

    # High Response Time
    - alert: HighResponseTime
      expr: |
        histogram_quantile(0.95,
          sum(rate(http_request_duration_seconds_bucket[5m])) by (le)
        ) > 2
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "High response time"
        description: "P95 latency is {{ $value }}s (threshold: 2s)"

    # Database Connection Pool Exhaustion
    - alert: DatabaseConnectionPoolHigh
      expr: |
        pg_stat_activity_count > 80
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "Database connection pool usage high"
        description: "{{ $value }} connections active (threshold: 80)"

    # Pod Restart
    - alert: PodRestarting
      expr: |
        rate(kube_pod_container_status_restarts_total[15m]) > 0
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "Pod {{ $labels.pod }} is restarting"
        description: "Pod has restarted {{ $value }} times in the last 15 minutes"

    # Disk Space
    - alert: DiskSpaceRunningOut
      expr: |
        (
          node_filesystem_avail_bytes{mountpoint="/"}
          /
          node_filesystem_size_bytes{mountpoint="/"}
        ) < 0.1
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "Disk space running out"
        description: "Only {{ $value | humanizePercentage }} disk space remaining"
```


### Alertmanager Configuration

**infrastructure/kubernetes/monitoring/alertmanager-config.yaml**

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: alertmanager-prometheus-kube-prometheus-alertmanager
  namespace: monitoring
stringData:
  alertmanager.yaml: |
    global:
      resolve_timeout: 5m
      slack_api_url: 'YOUR_SLACK_WEBHOOK_URL'

    route:
      group_by: ['alertname', 'cluster', 'service']
      group_wait: 10s
      group_interval: 10s
      repeat_interval: 12h
      receiver: 'slack-notifications'
      routes:
      - match:
          severity: critical
        receiver: 'slack-critical'
        continue: true
      - match:
          severity: warning
        receiver: 'slack-warnings'

    receivers:
    - name: 'slack-notifications'
      slack_configs:
      - channel: '#devops-alerts'
        title: 'Car Service Alert'
        text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'

    - name: 'slack-critical'
      slack_configs:
      - channel: '#critical-alerts'
        title: '🚨 CRITICAL ALERT'
        text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'
        send_resolved: true

    - name: 'slack-warnings'
      slack_configs:
      - channel: '#warnings'
        title: '⚠️ Warning'
        text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'
```


## 5. Deployment Script

**scripts/deploy-observability.sh**

```bash
#!/bin/bash

set -e

echo "🚀 Deploying Observability Stack"

# Create namespaces
echo "📦 Creating namespaces..."
kubectl apply -f infrastructure/kubernetes/monitoring/namespace.yaml

# Deploy ELK Stack
echo "📊 Deploying Elasticsearch..."
kubectl apply -f infrastructure/kubernetes/elk/elasticsearch.yaml
kubectl rollout status statefulset/elasticsearch -n logging --timeout=10m

echo "📊 Deploying Logstash..."
kubectl apply -f infrastructure/kubernetes/elk/logstash.yaml
kubectl rollout status deployment/logstash -n logging --timeout=5m

echo "📊 Deploying Filebeat..."
kubectl apply -f infrastructure/kubernetes/elk/filebeat.yaml
kubectl rollout status daemonset/filebeat -n logging --timeout=5m

echo "📊 Deploying Kibana..."
kubectl apply -f infrastructure/kubernetes/elk/kibana.yaml
kubectl rollout status deployment/kibana -n logging --timeout=5m

# Deploy Prometheus + Grafana
echo "📈 Deploying Prometheus Stack..."
helm upgrade --install prometheus prometheus-community/kube-prometheus-stack \
  --namespace monitoring \
  --values infrastructure/helm/prometheus-values.yaml

# Apply custom ServiceMonitors
echo "📈 Applying ServiceMonitors..."
kubectl apply -f infrastructure/kubernetes/monitoring/servicemonitor.yaml

# Apply AlertRules
echo "🔔 Applying Alert Rules..."
kubectl apply -f infrastructure/kubernetes/monitoring/prometheus-rules.yaml

# Get access information
echo ""
echo "✅ Deployment Complete!"
echo ""
echo "📊 Kibana: http://$(kubectl get svc kibana -n logging -o jsonpath='{.status.loadBalancer.ingress[^0].hostname}'):5601"
echo "📈 Grafana: http://$(kubectl get svc prometheus-grafana -n monitoring -o jsonpath='{.status.loadBalancer.ingress[^0].hostname}')"
echo ""
echo "🔐 Grafana Credentials:"
echo "   Username: admin"
echo "   Password: $(kubectl get secret -n monitoring prometheus-grafana -o jsonpath='{.data.admin-password}' | base64 -d)"
```


## Architecture Benefits Summary

| Component | Purpose | Retention | Query Performance |
| :-- | :-- | :-- | :-- |
| **Elasticsearch** | Log storage \& search | 30 days | Fast text search |
| **Kibana** | Log exploration | N/A | Deep log analysis |
| **Prometheus** | Metrics storage | 30 days | Time-series queries |
| **Grafana** | Unified dashboards | N/A | Real-time visualization |

การผสมผสาน ELK และ Grafana ให้ observability ที่สมบูรณ์ โดย ELK จัดการ logs และ Grafana แสดงทั้ง metrics และ logs ในที่เดียว


## การเชื่อมต่อ Grafana กับ Elasticsearch สำหรับ Dashboard Logs

การเชื่อมต่อ Grafana กับ Elasticsearch ช่วยให้สามารถแสดง logs และ metrics ในที่เดียวกัน สร้าง unified observability platform[^1]

## 1. เพิ่ม Elasticsearch Data Source ใน Grafana

### วิธีที่ 1: ผ่าน UI

**ขั้นตอนการเพิ่ม Data Source**

1. เข้า Grafana → Configuration → Data Sources
2. คลิก "Add data source"
3. เลือก "Elasticsearch"
4. กรอกข้อมูลตามด้านล่าง

### วิธีที่ 2: ผ่าน Configuration File

**infrastructure/grafana/datasources/elasticsearch.yaml**

```yaml
apiVersion: 1

datasources:
  - name: Elasticsearch-Logs
    type: elasticsearch
    access: proxy
    url: http://elasticsearch.logging.svc.cluster.local:9200
    jsonData:
      # Elasticsearch version
      esVersion: "8.0.0"
      
      # Time field name
      timeField: "@timestamp"
      
      # Index pattern
      index: "car-service-*"
      interval: Daily
      
      # Log configuration
      logMessageField: "message"
      logLevelField: "log_level"
      
      # Maximum concurrent shard requests
      maxConcurrentShardRequests: 5
      
      # Timeout in seconds
      timeoutSeconds: 30
      
      # Include frozen indices
      includeFrozen: false
      
    # Basic auth (if enabled)
    # basicAuth: true
    # basicAuthUser: elastic
    # secureJsonData:
    #   basicAuthPassword: your-password
    
    # TLS/SSL configuration (if needed)
    # jsonData:
    #   tlsSkipVerify: false
    # secureJsonData:
    #   tlsCACert: |
    #     -----BEGIN CERTIFICATE-----
    #     ...
    #     -----END CERTIFICATE-----

  - name: Elasticsearch-Metrics
    type: elasticsearch
    access: proxy
    url: http://elasticsearch.logging.svc.cluster.local:9200
    jsonData:
      esVersion: "8.0.0"
      timeField: "@timestamp"
      index: "metricbeat-*"
      interval: Daily
```


### วิธีที่ 3: ผ่าน Kubernetes ConfigMap

**infrastructure/kubernetes/monitoring/grafana-datasource.yaml**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-datasource-elasticsearch
  namespace: monitoring
  labels:
    grafana_datasource: "1"
data:
  elasticsearch-datasource.yaml: |
    apiVersion: 1
    datasources:
      - name: Elasticsearch-Logs
        type: elasticsearch
        access: proxy
        url: http://elasticsearch.logging.svc.cluster.local:9200
        isDefault: false
        editable: true
        jsonData:
          esVersion: "8.0.0"
          timeField: "@timestamp"
          index: "car-service-*"
          interval: Daily
          logMessageField: "message"
          logLevelField: "log_level"
          maxConcurrentShardRequests: 5
```

**Apply ConfigMap**

```bash
kubectl apply -f infrastructure/kubernetes/monitoring/grafana-datasource.yaml

# Restart Grafana to load new datasource
kubectl rollout restart deployment/prometheus-grafana -n monitoring
```


## 2. สร้าง Log Dashboard

### Dashboard สำหรับ Application Logs

**infrastructure/grafana-dashboards/application-logs-dashboard.json**

```json
{
  "dashboard": {
    "title": "Car Service Application Logs",
    "timezone": "browser",
    "panels": [
      {
        "id": 1,
        "title": "Log Volume Over Time",
        "type": "graph",
        "gridPos": {
          "x": 0,
          "y": 0,
          "w": 24,
          "h": 8
        },
        "targets": [
          {
            "datasource": "Elasticsearch-Logs",
            "metrics": [
              {
                "type": "count",
                "id": "1"
              }
            ],
            "bucketAggs": [
              {
                "type": "date_histogram",
                "field": "@timestamp",
                "id": "2",
                "settings": {
                  "interval": "auto",
                  "min_doc_count": "0",
                  "trimEdges": "0"
                }
              },
              {
                "type": "terms",
                "field": "log_level.keyword",
                "id": "3",
                "settings": {
                  "size": "10",
                  "order": "desc",
                  "orderBy": "_count"
                }
              }
            ],
            "query": "kubernetes.namespace:production",
            "timeField": "@timestamp"
          }
        ],
        "yaxes": [
          {
            "label": "Log Count",
            "format": "short"
          }
        ],
        "legend": {
          "show": true,
          "values": true,
          "current": true
        }
      },
      {
        "id": 2,
        "title": "Error Logs",
        "type": "logs",
        "gridPos": {
          "x": 0,
          "y": 8,
          "w": 12,
          "h": 10
        },
        "targets": [
          {
            "datasource": "Elasticsearch-Logs",
            "query": "log_level:ERROR AND kubernetes.namespace:production",
            "timeField": "@timestamp",
            "metrics": [
              {
                "type": "logs"
              }
            ]
          }
        ],
        "options": {
          "showTime": true,
          "showLabels": false,
          "wrapLogMessage": true,
          "sortOrder": "Descending"
        }
      },
      {
        "id": 3,
        "title": "Warning Logs",
        "type": "logs",
        "gridPos": {
          "x": 12,
          "y": 8,
          "w": 12,
          "h": 10
        },
        "targets": [
          {
            "datasource": "Elasticsearch-Logs",
            "query": "log_level:WARN AND kubernetes.namespace:production",
            "timeField": "@timestamp",
            "metrics": [
              {
                "type": "logs"
              }
            ]
          }
        ]
      },
      {
        "id": 4,
        "title": "Logs by Service",
        "type": "piechart",
        "gridPos": {
          "x": 0,
          "y": 18,
          "w": 8,
          "h": 8
        },
        "targets": [
          {
            "datasource": "Elasticsearch-Logs",
            "metrics": [
              {
                "type": "count",
                "id": "1"
              }
            ],
            "bucketAggs": [
              {
                "type": "terms",
                "field": "kubernetes.container.name.keyword",
                "id": "2",
                "settings": {
                  "size": "10",
                  "order": "desc",
                  "orderBy": "_count"
                }
              }
            ],
            "query": "kubernetes.namespace:production"
          }
        ]
      },
      {
        "id": 5,
        "title": "Top Error Messages",
        "type": "table",
        "gridPos": {
          "x": 8,
          "y": 18,
          "w": 16,
          "h": 8
        },
        "targets": [
          {
            "datasource": "Elasticsearch-Logs",
            "metrics": [
              {
                "type": "count",
                "id": "1"
              }
            ],
            "bucketAggs": [
              {
                "type": "terms",
                "field": "log_message.keyword",
                "id": "2",
                "settings": {
                  "size": "10",
                  "order": "desc",
                  "orderBy": "_count"
                }
              }
            ],
            "query": "log_level:ERROR AND kubernetes.namespace:production"
          }
        ],
        "transformations": [
          {
            "id": "organize",
            "options": {
              "excludeByName": {},
              "indexByName": {},
              "renameByName": {
                "log_message.keyword": "Error Message",
                "Count": "Occurrences"
              }
            }
          }
        ]
      }
    ],
    "templating": {
      "list": [
        {
          "name": "namespace",
          "type": "query",
          "datasource": "Elasticsearch-Logs",
          "query": {
            "query": "*",
            "field": "kubernetes.namespace.keyword"
          },
          "multi": false,
          "includeAll": false,
          "current": {
            "value": "production"
          }
        },
        {
          "name": "service",
          "type": "query",
          "datasource": "Elasticsearch-Logs",
          "query": {
            "query": "kubernetes.namespace:$namespace",
            "field": "kubernetes.container.name.keyword"
          },
          "multi": true,
          "includeAll": true
        },
        {
          "name": "log_level",
          "type": "custom",
          "multi": true,
          "includeAll": true,
          "options": [
            { "text": "ERROR", "value": "ERROR" },
            { "text": "WARN", "value": "WARN" },
            { "text": "INFO", "value": "INFO" },
            { "text": "DEBUG", "value": "DEBUG" }
          ]
        }
      ]
    },
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "30s"
  }
}
```


## 3. ตัวอย่าง Query Patterns

### Basic Queries

```lucene
# All logs from production namespace
kubernetes.namespace:production

# Error logs only
log_level:ERROR

# Logs from specific service
kubernetes.container.name:nestjs-api

# Logs containing specific text
log_message:*booking*

# Combined query
log_level:ERROR AND kubernetes.container.name:nestjs-api AND log_message:*payment*

# Time range query (handled by Grafana UI)
@timestamp:[now-1h TO now]

# Exclude system logs
NOT kubernetes.namespace:(kube-system OR logging OR monitoring)

# Multiple services
kubernetes.container.name:(nestjs-api OR spring-api)

# Regular expression
log_message:/.*timeout.*/

# Field exists
_exists_:error_code

# Field does not exist
NOT _exists_:error_code

# Numeric range
response_time:[200 TO 500]
```


### Advanced Queries

```lucene
# HTTP 5xx errors with high response time
log_level:ERROR AND http_status:[500 TO 599] AND response_time:>1000

# Database query errors
log_message:*database* AND log_level:ERROR

# Specific user activity
user_id:"user-123" AND (log_message:*login* OR log_message:*logout*)

# API endpoint errors
kubernetes.container.name:nestjs-api AND log_message:*/api/v1/bookings* AND log_level:ERROR

# Slow queries
log_message:*query* AND execution_time:>5000

# Payment failures
kubernetes.container.name:spring-api AND log_message:*payment* AND log_level:ERROR
```


## 4. Dashboard สำหรับ Business Metrics

**infrastructure/grafana-dashboards/business-logs-dashboard.json**

```json
{
  "dashboard": {
    "title": "Car Service Business Metrics from Logs",
    "panels": [
      {
        "id": 1,
        "title": "Booking Events",
        "type": "graph",
        "targets": [
          {
            "datasource": "Elasticsearch-Logs",
            "metrics": [
              {
                "type": "count",
                "id": "1"
              }
            ],
            "bucketAggs": [
              {
                "type": "date_histogram",
                "field": "@timestamp",
                "id": "2"
              },
              {
                "type": "terms",
                "field": "event_type.keyword",
                "id": "3"
              }
            ],
            "query": "log_message:*BOOKING* AND (event_type:CREATED OR event_type:CONFIRMED OR event_type:CANCELLED)"
          }
        ]
      },
      {
        "id": 2,
        "title": "Payment Transactions",
        "type": "stat",
        "targets": [
          {
            "datasource": "Elasticsearch-Logs",
            "metrics": [
              {
                "type": "count",
                "id": "1"
              }
            ],
            "bucketAggs": [
              {
                "type": "terms",
                "field": "payment_status.keyword",
                "id": "2"
              }
            ],
            "query": "log_message:*PAYMENT* AND kubernetes.container.name:spring-api"
          }
        ]
      },
      {
        "id": 3,
        "title": "User Login Events",
        "type": "logs",
        "targets": [
          {
            "datasource": "Elasticsearch-Logs",
            "query": "log_message:*LOGIN* OR log_message:*AUTHENTICATION*",
            "timeField": "@timestamp"
          }
        ]
      },
      {
        "id": 4,
        "title": "Failed Transactions",
        "type": "table",
        "targets": [
          {
            "datasource": "Elasticsearch-Logs",
            "metrics": [
              {
                "type": "count",
                "id": "1"
              }
            ],
            "bucketAggs": [
              {
                "type": "terms",
                "field": "error_code.keyword",
                "id": "2",
                "settings": {
                  "size": "10",
                  "order": "desc"
                }
              },
              {
                "type": "terms",
                "field": "transaction_type.keyword",
                "id": "3"
              }
            ],
            "query": "log_level:ERROR AND (log_message:*PAYMENT* OR log_message:*BOOKING*)"
          }
        ]
      }
    ]
  }
}
```


## 5. การ Import Dashboard ผ่าน Kubernetes

**infrastructure/kubernetes/monitoring/grafana-dashboard-configmap.yaml**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-dashboard-logs
  namespace: monitoring
  labels:
    grafana_dashboard: "1"
data:
  application-logs.json: |
    {
      "dashboard": {
        "title": "Application Logs",
        ...
      }
    }
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-dashboard-provider
  namespace: monitoring
data:
  dashboards.yaml: |
    apiVersion: 1
    providers:
      - name: 'Logs'
        orgId: 1
        folder: 'Logs'
        type: file
        disableDeletion: false
        updateIntervalSeconds: 30
        allowUiUpdates: true
        options:
          path: /var/lib/grafana/dashboards
```

**Update Grafana Deployment**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus-grafana
  namespace: monitoring
spec:
  template:
    spec:
      containers:
      - name: grafana
        volumeMounts:
        - name: dashboard-logs
          mountPath: /var/lib/grafana/dashboards/logs
        - name: dashboard-provider
          mountPath: /etc/grafana/provisioning/dashboards
      volumes:
      - name: dashboard-logs
        configMap:
          name: grafana-dashboard-logs
      - name: dashboard-provider
        configMap:
          name: grafana-dashboard-provider
```


## 6. การใช้งาน Explore Mode

### ตัวอย่างการ Query ใน Explore

```bash
# เปิด Grafana Explore
# 1. Click "Explore" icon (compass) ใน sidebar
# 2. เลือก "Elasticsearch-Logs" data source
# 3. ใส่ query และ select time range
```

**Example Explore Queries:**

```lucene
# Quick error investigation
log_level:ERROR AND kubernetes.namespace:production

# Trace specific request
request_id:"req-123456"

# Performance issues
log_message:*slow* OR execution_time:>3000

# Security events
log_message:*authentication* OR log_message:*authorization*
```


## 7. Alert Rules จาก Elasticsearch Logs

**infrastructure/kubernetes/monitoring/elasticsearch-alert-rules.yaml**

```yaml
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: elasticsearch-log-alerts
  namespace: monitoring
spec:
  groups:
  - name: elasticsearch-logs
    interval: 1m
    rules:
    # Alert on error rate from logs
    - alert: HighErrorRateInLogs
      expr: |
        sum(rate(elasticsearch_query_count{log_level="ERROR"}[5m])) 
        / 
        sum(rate(elasticsearch_query_count[5m])) > 0.1
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "High error rate in application logs"
        description: "Error log rate is {{ $value | humanizePercentage }}"

    # Alert on specific error patterns
    - alert: PaymentFailureSpike
      expr: |
        sum(rate(elasticsearch_query_count{
          log_message=~".*payment.*failed.*"
        }[5m])) > 5
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: "Payment failure spike detected"
        description: "{{ $value }} payment failures per second"
```


## 8. Testing Connection

**Test script: scripts/test-grafana-elasticsearch.sh**

```bash
#!/bin/bash

# Test Elasticsearch connectivity
echo "Testing Elasticsearch connection..."
ES_URL="http://elasticsearch.logging.svc.cluster.local:9200"

# Check cluster health
curl -X GET "$ES_URL/_cluster/health?pretty"

# Check indices
curl -X GET "$ES_URL/_cat/indices/car-service-*?v"

# Test query
curl -X GET "$ES_URL/car-service-*/_search?pretty" -H 'Content-Type: application/json' -d'
{
  "query": {
    "match": {
      "log_level": "ERROR"
    }
  },
  "size": 5
}
'

# Test Grafana API
echo ""
echo "Testing Grafana API..."
GRAFANA_URL="http://prometheus-grafana.monitoring.svc.cluster.local"
GRAFANA_USER="admin"
GRAFANA_PASS=$(kubectl get secret -n monitoring prometheus-grafana -o jsonpath='{.data.admin-password}' | base64 -d)

# List data sources
curl -u "$GRAFANA_USER:$GRAFANA_PASS" "$GRAFANA_URL/api/datasources"

echo ""
echo "✅ Tests complete"
```


## Summary: Grafana + Elasticsearch Integration

| Feature | Configuration | Purpose |
| :-- | :-- | :-- |
| **Data Source** | URL: `elasticsearch.logging:9200` | Connect to ES |
| **Index Pattern** | `car-service-*` | Query logs |
| **Time Field** | `@timestamp` | Time series data |
| **Log Fields** | `message`, `log_level` | Display logs |
| **Dashboard Types** | Logs, Graph, Table, Pie | Visualize data |
| **Query Language** | Lucene | Search logs |
| **Refresh Rate** | 30s - 5m | Real-time updates |

การเชื่อมต่อ Grafana กับ Elasticsearch ทำให้สามารถดู metrics จาก Prometheus และ logs จาก Elasticsearch ในที่เดียวกัน สร้าง unified observability platform ที่ทรงพลัง


<hr><hr>

## การใช้ n8n สำหรับระบบแจ้งเตือน (Notification Automation)

n8n เป็น workflow automation tool แบบ open-source ที่ช่วยให้สร้าง automated workflows สำหรับแจ้งเตือนและ integrate กับระบบต่างๆ ได้อย่างง่ายดาย

## 1. ภาพรวม n8n Integration Architecture

```
┌─────────────────────────────────────────────────────────────┐
│              APPLICATION EVENTS                              │
│  Booking Created │ Payment Success │ Repair Complete        │
└─────────┬────────────────┬────────────────┬─────────────────┘
          │                │                │
          ▼                ▼                ▼
┌─────────────────────────────────────────────────────────────┐
│                    KAFKA TOPICS                              │
│  booking-events  │  payment-events  │  repair-events        │
└─────────┬────────────────┬────────────────┬─────────────────┘
          │                │                │
          │ Webhooks       │                │
          ▼                ▼                ▼
┌─────────────────────────────────────────────────────────────┐
│                      n8n WORKFLOWS                           │
│  • Notification Router                                       │
│  • Customer Notifications                                    │
│  • Admin Alerts                                             │
│  • Technician Assignments                                   │
└─────────┬────────────┬──────────┬──────────┬────────────────┘
          │            │          │          │
          ▼            ▼          ▼          ▼
┌─────────────┬────────────┬──────────┬──────────────────────┐
│   Slack     │   Email    │   SMS    │  LINE/WhatsApp       │
│  (DevOps)   │ (Customer) │ (Urgent) │  (Customer)          │
└─────────────┴────────────┴──────────┴──────────────────────┘
```


## 2. การติดตั้ง n8n บน Kubernetes

### n8n Deployment

**infrastructure/kubernetes/n8n/deployment.yaml**

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: n8n
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: n8n-data
  namespace: n8n
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: gp2
  resources:
    requests:
      storage: 10Gi
---
apiVersion: v1
kind: Secret
metadata:
  name: n8n-secrets
  namespace: n8n
type: Opaque
stringData:
  N8N_BASIC_AUTH_USER: admin
  N8N_BASIC_AUTH_PASSWORD: changeme123
  N8N_ENCRYPTION_KEY: "your-encryption-key-32-chars"
  WEBHOOK_URL: "https://n8n.car-service.com"
  
  # Email SMTP
  SMTP_HOST: smtp.gmail.com
  SMTP_PORT: "587"
  SMTP_USER: notifications@car-service.com
  SMTP_PASSWORD: your-app-password
  
  # Slack
  SLACK_WEBHOOK_URL: https://hooks.slack.com/services/YOUR/WEBHOOK/URL
  
  # LINE Notify
  LINE_NOTIFY_TOKEN: your-line-notify-token
  
  # Twilio SMS
  TWILIO_ACCOUNT_SID: your-account-sid
  TWILIO_AUTH_TOKEN: your-auth-token
  TWILIO_PHONE_NUMBER: "+1234567890"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: n8n
  namespace: n8n
spec:
  replicas: 1
  selector:
    matchLabels:
      app: n8n
  template:
    metadata:
      labels:
        app: n8n
    spec:
      containers:
      - name: n8n
        image: n8nio/n8n:latest
        ports:
        - containerPort: 5678
          name: http
        env:
        - name: N8N_HOST
          value: "n8n.car-service.com"
        - name: N8N_PORT
          value: "5678"
        - name: N8N_PROTOCOL
          value: "https"
        - name: NODE_ENV
          value: "production"
        - name: EXECUTIONS_PROCESS
          value: "main"
        - name: EXECUTIONS_MODE
          value: "regular"
        - name: N8N_BASIC_AUTH_ACTIVE
          value: "true"
        - name: GENERIC_TIMEZONE
          value: "Asia/Bangkok"
        - name: N8N_DIAGNOSTICS_ENABLED
          value: "false"
        - name: N8N_LOG_LEVEL
          value: "info"
        
        envFrom:
        - secretRef:
            name: n8n-secrets
        
        volumeMounts:
        - name: data
          mountPath: /home/node/.n8n
        
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        
        livenessProbe:
          httpGet:
            path: /healthz
            port: 5678
          initialDelaySeconds: 30
          periodSeconds: 10
        
        readinessProbe:
          httpGet:
            path: /healthz
            port: 5678
          initialDelaySeconds: 10
          periodSeconds: 5
      
      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: n8n-data
---
apiVersion: v1
kind: Service
metadata:
  name: n8n
  namespace: n8n
spec:
  selector:
    app: n8n
  ports:
  - port: 5678
    targetPort: 5678
    name: http
  type: ClusterIP
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: n8n-ingress
  namespace: n8n
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - n8n.car-service.com
    secretName: n8n-tls
  rules:
  - host: n8n.car-service.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: n8n
            port:
              number: 5678
```


### Deploy n8n

```bash
# Deploy n8n
kubectl apply -f infrastructure/kubernetes/n8n/deployment.yaml

# Check status
kubectl get pods -n n8n

# Get n8n URL
echo "n8n URL: https://$(kubectl get ingress n8n-ingress -n n8n -o jsonpath='{.spec.rules[0].host}')"

# Get credentials
echo "Username: $(kubectl get secret n8n-secrets -n n8n -o jsonpath='{.data.N8N_BASIC_AUTH_USER}' | base64 -d)"
echo "Password: $(kubectl get secret n8n-secrets -n n8n -o jsonpath='{.data.N8N_BASIC_AUTH_PASSWORD}' | base64 -d)"
```


## 3. n8n Workflows สำหรับแจ้งเตือน

### Workflow 1: Booking Notification

**จุดประสงค์:** แจ้งเตือนลูกค้าเมื่อมีการจอง, ยืนยัน, หรือยกเลิก

**n8n Workflow JSON:**

```json
{
  "name": "Booking Notification Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "booking-webhook",
        "responseMode": "onReceived",
        "options": {}
      },
      "name": "Webhook - Booking Event",
      "type": "n8n-nodes-base.webhook",
      "position": [250, 300]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.eventType}}",
              "operation": "equals",
              "value2": "BOOKING_CREATED"
            }
          ]
        }
      },
      "name": "If Booking Created",
      "type": "n8n-nodes-base.if",
      "position": [450, 200]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.eventType}}",
              "operation": "equals",
              "value2": "BOOKING_CONFIRMED"
            }
          ]
        }
      },
      "name": "If Booking Confirmed",
      "position": [450, 300]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.eventType}}",
              "operation": "equals",
              "value2": "BOOKING_CANCELLED"
            }
          ]
        }
      },
      "name": "If Booking Cancelled",
      "position": [450, 400]
    },
    {
      "parameters": {
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "url": "https://api.car-service.com/api/v1/users/={{$json.customerId}}",
        "options": {}
      },
      "name": "Get Customer Details",
      "type": "n8n-nodes-base.httpRequest",
      "position": [650, 250]
    },
    {
      "parameters": {
        "fromEmail": "notifications@car-service.com",
        "toEmail": "={{$node['Get Customer Details'].json.email}}",
        "subject": "การจองของคุณได้รับการยืนยันแล้ว",
        "text": "เรียน คุณ {{$node['Get Customer Details'].json.name}}\n\nการจองของคุณได้รับการยืนยันแล้ว\n\nรายละเอียด:\n- หมายเลขจอง: {{$json.bookingId}}\n- วันที่: {{$json.bookingDate}}\n- ประเภทบริการ: {{$json.serviceType}}\n\nขอบคุณที่ใช้บริการ\nศูนย์บริการรถยนต์",
        "options": {
          "allowUnauthorizedCerts": false
        }
      },
      "name": "Send Email - Confirmed",
      "type": "n8n-nodes-base.emailSend",
      "credentials": {
        "smtp": {
          "id": "1",
          "name": "SMTP Account"
        }
      },
      "position": [850, 200]
    },
    {
      "parameters": {
        "message": "=📅 *การจองใหม่*\n\nลูกค้า: {{$node['Get Customer Details'].json.name}}\nหมายเลขจอง: {{$json.bookingId}}\nวันที่: {{$json.bookingDate}}\nบริการ: {{$json.serviceType}}",
        "otherOptions": {}
      },
      "name": "Send LINE Notify",
      "type": "n8n-nodes-base.line",
      "credentials": {
        "lineNotifyOAuth2Api": {
          "id": "2",
          "name": "LINE Notify"
        }
      },
      "position": [850, 300]
    },
    {
      "parameters": {
        "channel": "#bookings",
        "text": "=:calendar: *New Booking*\n\nCustomer: {{$node['Get Customer Details'].json.name}}\nBooking ID: {{$json.bookingId}}\nDate: {{$json.bookingDate}}\nService: {{$json.serviceType}}",
        "otherOptions": {
          "username": "Booking Bot"
        }
      },
      "name": "Send Slack Notification",
      "type": "n8n-nodes-base.slack",
      "credentials": {
        "slackApi": {
          "id": "3",
          "name": "Slack"
        }
      },
      "position": [850, 400]
    }
  ],
  "connections": {
    "Webhook - Booking Event": {
      "main": [
        [
          {
            "node": "If Booking Created",
            "type": "main",
            "index": 0
          },
          {
            "node": "If Booking Confirmed",
            "type": "main",
            "index": 0
          },
          {
            "node": "If Booking Cancelled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Booking Created": {
      "main": [
        [
          {
            "node": "Get Customer Details",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Booking Confirmed": {
      "main": [
        [
          {
            "node": "Get Customer Details",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Customer Details": {
      "main": [
        [
          {
            "node": "Send Email - Confirmed",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send LINE Notify",
            "type": "main",
            "index": 0
          },
          {
            "node": "Send Slack Notification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true
}
```


### Workflow 2: System Alert Notification

**จุดประสงค์:** แจ้งเตือนทีม DevOps เมื่อมีปัญหาระบบ

```json
{
  "name": "System Alert Workflow",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "alertmanager-webhook",
        "responseMode": "onReceived"
      },
      "name": "Webhook - Alertmanager",
      "type": "n8n-nodes-base.webhook",
      "position": [250, 300]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.alerts[0].labels.severity}}",
              "operation": "equals",
              "value2": "critical"
            }
          ]
        }
      },
      "name": "If Critical Alert",
      "type": "n8n-nodes-base.if",
      "position": [450, 250]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.alerts[0].labels.severity}}",
              "operation": "equals",
              "value2": "warning"
            }
          ]
        }
      },
      "name": "If Warning Alert",
      "position": [450, 400]
    },
    {
      "parameters": {
        "channel": "#critical-alerts",
        "text": "=🚨 *CRITICAL ALERT*\n\n*Alert:* {{$json.alerts[0].labels.alertname}}\n*Description:* {{$json.alerts[0].annotations.description}}\n*Service:* {{$json.alerts[0].labels.service}}\n*Environment:* {{$json.alerts[0].labels.environment}}\n\n@channel - Immediate action required!",
        "otherOptions": {
          "username": "Alert Bot",
          "icon_emoji": ":rotating_light:"
        }
      },
      "name": "Slack - Critical",
      "type": "n8n-nodes-base.slack",
      "position": [650, 150]
    },
    {
      "parameters": {
        "to": "+66812345678,+66898765432",
        "message": "=🚨 CRITICAL: {{$json.alerts[0].labels.alertname}}\n{{$json.alerts[0].annotations.description}}",
        "options": {}
      },
      "name": "SMS - Critical (Twilio)",
      "type": "n8n-nodes-base.twilio",
      "credentials": {
        "twilioApi": {
          "id": "4",
          "name": "Twilio"
        }
      },
      "position": [650, 250]
    },
    {
      "parameters": {
        "fromEmail": "alerts@car-service.com",
        "toEmail": "devops-team@car-service.com",
        "subject": "=🚨 CRITICAL ALERT: {{$json.alerts[0].labels.alertname}}",
        "html": "=<h2 style='color: red;'>Critical Alert</h2>\n<p><strong>Alert:</strong> {{$json.alerts[0].labels.alertname}}</p>\n<p><strong>Description:</strong> {{$json.alerts[0].annotations.description}}</p>\n<p><strong>Service:</strong> {{$json.alerts[0].labels.service}}</p>\n<p><strong>Environment:</strong> {{$json.alerts[0].labels.environment}}</p>\n<p><strong>Started:</strong> {{$json.alerts[0].startsAt}}</p>"
      },
      "name": "Email - Critical",
      "type": "n8n-nodes-base.emailSend",
      "position": [650, 350]
    },
    {
      "parameters": {
        "channel": "#warnings",
        "text": "=⚠️ *Warning Alert*\n\n*Alert:* {{$json.alerts[0].labels.alertname}}\n*Description:* {{$json.alerts[0].annotations.description}}\n*Service:* {{$json.alerts[0].labels.service}}",
        "otherOptions": {
          "username": "Alert Bot"
        }
      },
      "name": "Slack - Warning",
      "type": "n8n-nodes-base.slack",
      "position": [650, 400]
    }
  ],
  "connections": {
    "Webhook - Alertmanager": {
      "main": [
        [
          {
            "node": "If Critical Alert",
            "type": "main",
            "index": 0
          },
          {
            "node": "If Warning Alert",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Critical Alert": {
      "main": [
        [
          {
            "node": "Slack - Critical",
            "type": "main",
            "index": 0
          },
          {
            "node": "SMS - Critical (Twilio)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Email - Critical",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If Warning Alert": {
      "main": [
        [
          {
            "node": "Slack - Warning",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true
}
```


## 4. การเชื่อมต่อ Application กับ n8n

### NestJS Integration

**backend/nestjs-api/src/notifications/n8n.service.ts**

```typescript
import { Injectable, HttpService } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class N8nService {
  private readonly n8nUrl: string;
  
  constructor(
    private httpService: HttpService,
    private configService: ConfigService,
  ) {
    this.n8nUrl = this.configService.get('N8N_WEBHOOK_URL');
  }

  async sendBookingNotification(bookingEvent: any): Promise<void> {
    try {
      await this.httpService
        .post(`${this.n8nUrl}/webhook/booking-webhook`, bookingEvent)
        .toPromise();
      
      console.log('Booking notification sent to n8n');
    } catch (error) {
      console.error('Failed to send notification to n8n:', error);
    }
  }

  async sendRepairNotification(repairEvent: any): Promise<void> {
    try {
      await this.httpService
        .post(`${this.n8nUrl}/webhook/repair-webhook`, repairEvent)
        .toPromise();
      
      console.log('Repair notification sent to n8n');
    } catch (error) {
      console.error('Failed to send notification to n8n:', error);
    }
  }

  async sendPaymentNotification(paymentEvent: any): Promise<void> {
    try {
      await this.httpService
        .post(`${this.n8nUrl}/webhook/payment-webhook`, paymentEvent)
        .toPromise();
      
      console.log('Payment notification sent to n8n');
    } catch (error) {
      console.error('Failed to send notification to n8n:', error);
    }
  }
}
```

**Usage in Service:**

```typescript
@Injectable()
export class BookingService {
  constructor(
    private bookingRepository: BookingRepository,
    private n8nService: N8nService,
  ) {}

  async createBooking(createBookingDto: CreateBookingDto): Promise<Booking> {
    const booking = await this.bookingRepository.save(createBookingDto);
    
    // Send notification to n8n
    await this.n8nService.sendBookingNotification({
      eventType: 'BOOKING_CREATED',
      bookingId: booking.id,
      customerId: booking.customerId,
      bookingDate: booking.bookingDate,
      serviceType: booking.serviceType,
      timestamp: new Date().toISOString(),
    });
    
    return booking;
  }
}
```


### Alertmanager Integration

**infrastructure/kubernetes/monitoring/alertmanager-config.yaml**

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: alertmanager-prometheus-kube-prometheus-alertmanager
  namespace: monitoring
stringData:
  alertmanager.yaml: |
    global:
      resolve_timeout: 5m

    route:
      group_by: ['alertname', 'cluster', 'service']
      group_wait: 10s
      group_interval: 10s
      repeat_interval: 12h
      receiver: 'n8n-webhook'

    receivers:
    - name: 'n8n-webhook'
      webhook_configs:
      - url: 'https://n8n.car-service.com/webhook/alertmanager-webhook'
        send_resolved: true
        http_config:
          bearer_token: 'your-bearer-token'
```


## 5. n8n Workflow Templates

### Template: Repair Status Update

```javascript
// Workflow: Repair Status Notification
// Trigger: Webhook
// Steps:
// 1. Receive repair update
// 2. Get customer info from API
// 3. Format message based on status
// 4. Send via LINE/Email/SMS

{
  "webhook": {
    "eventType": "REPAIR_STATUS_UPDATE",
    "repairId": "repair-123",
    "customerId": "customer-456",
    "status": "IN_PROGRESS",
    "progress": 60,
    "estimatedCompletion": "2025-11-26T15:00:00Z"
  }
}

// Message template:
"สวัสดีค่ะคุณ {{customerName}}

📋 สถานะการซ่อมของคุณ
รหัสงาน: {{repairId}}
สถานะ: {{status_thai}}
ความคืบหน้า: {{progress}}%
เสร็จโดยประมาณ: {{estimatedTime}}

ขอบคุณที่ใช้บริการค่ะ"
```


## 6. Monitoring n8n

**Prometheus ServiceMonitor for n8n:**

```yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: n8n-monitor
  namespace: monitoring
spec:
  selector:
    matchLabels:
      app: n8n
  namespaceSelector:
    matchNames:
    - n8n
  endpoints:
  - port: http
    interval: 30s
    path: /metrics
```


## Summary: n8n Notification System

| ฟีเจอร์ | รายละเอียด | ช่องทาง |
| :-- | :-- | :-- |
| **Booking Notifications** | แจ้งเตือนการจอง/ยืนยัน/ยกเลิก | Email, LINE, SMS |
| **Repair Updates** | แจ้งสถานะการซ่อมแบบ real-time | LINE, Push Notification |
| **Payment Confirmations** | ยืนยันการชำระเงิน | Email, SMS |
| **System Alerts** | แจ้งเตือนปัญหาระบบ | Slack, SMS, Email |
| **Marketing** | ส่งโปรโมชั่น/ข่าวสาร | Email, LINE Broadcast |
| **Reminders** | เตือนนัดหมาย 1 วันก่อน | SMS, LINE |

n8n ทำให้การจัดการ notification แบบ centralized ง่ายขึ้น ไม่ต้อง hard-code ใน application สามารถปรับเปลี่ยน workflow ได้ผ่าน UI โดยไม่ต้อง redeploy code
